/*
 * ============================================================================
 * prob01.cpp - 괄호 매칭 번호 부여 (Parenthesis Numbering)
 * ============================================================================
 * 
 * [문제 개요]
 * - 수식이나 문자열에서 괄호들을 스캔하여 짝이 맞는 괄호에 같은 번호를 부여
 * - 여는 괄호 '('가 나올 때마다 새로운 번호를 부여
 * - 닫는 괄호 ')'는 가장 최근에 열린 괄호의 번호를 사용
 * 
 * [예시]
 * 입력: "((a+b)*(c+d))"
 * 괄호만 추출: ( ( ) ( ) )
 * 번호 부여:   1 2 2 3 3 1
 * 출력: "1 2 2 3 3 1"
 * 
 * [알고리즘]
 * - 스택을 이용한 괄호 매칭
 * - 여는 괄호: 새 번호 부여 후 스택에 push
 * - 닫는 괄호: 스택 top의 번호 사용 후 pop
 * 
 * [시간 복잡도] O(N) - 문자열 한 번 스캔
 * [공간 복잡도] O(N) - 스택 깊이 (최악의 경우 모두 여는 괄호)
 */

#include <iostream>
#include <string>
using namespace std;

const int MAX_CAPACITY = 100;   // 스택 최대 용량

/*
 * ============================================================================
 * Paren 클래스 - 정수를 저장하는 스택 (괄호 번호 저장용)
 * ============================================================================
 * 
 * [역할]
 * - 여는 괄호의 번호를 저장
 * - 닫는 괄호를 만나면 가장 최근 여는 괄호의 번호를 반환
 * 
 * [구현 방식]
 * - 배열 기반 스택
 * - count: 현재 스택에 저장된 원소 수 (동시에 다음 삽입 위치)
 */
class Paren {
private:
    int data[MAX_CAPACITY];     // 괄호 번호 저장 배열
    int count = 0;              // 현재 원소 수
    
public:
    /*
     * empty() - 스택이 비어있는지 확인
     * 반환: count == 0이면 true
     */
    bool empty() { return count == 0; }
    
    /*
     * full() - 스택이 가득 찼는지 확인
     * 반환: count == MAX_CAPACITY면 true
     */
    bool full()  { return count == MAX_CAPACITY; }

    /*
     * push(x) - 스택에 원소 추가
     * 매개변수: x - 추가할 괄호 번호
     * 예외: 스택이 가득 찬 경우 runtime_error
     */
    void push(int x) {
        if (full()) throw runtime_error("Full");
        data[count++] = x;
    }
    
    /*
     * pop() - 스택에서 원소 제거
     * 예외: 스택이 비어있는 경우 runtime_error
     * 참고: 반환값 없이 제거만 수행 (top()으로 먼저 값 확인)
     */
    void pop() {
        if (empty()) throw runtime_error("Empty");
        --count;
    }
    
    /*
     * top() - 스택의 최상위 원소 반환
     * 반환: 가장 최근에 push된 괄호 번호
     * 예외: 스택이 비어있는 경우 runtime_error
     */
    int top() {
        if (empty()) throw runtime_error("Empty");
        return data[count - 1];
    }
};

/*
 * ============================================================================
 * paren_count() - 괄호에 번호를 부여하여 문자열로 반환
 * ============================================================================
 * 
 * [매개변수]
 * - ex_input: 괄호가 포함된 입력 문자열 (수식 등)
 * 
 * [반환값]
 * - 각 괄호에 부여된 번호를 공백으로 구분한 문자열
 * 
 * [알고리즘 상세]
 * 
 * 1. next_id: 다음에 부여할 괄호 번호 (1부터 시작)
 * 
 * 2. 문자열을 한 문자씩 스캔:
 *    
 *    a. 여는 괄호 '(' 발견:
 *       - next_id를 증가시켜 새 번호 생성
 *       - 스택에 번호 push (나중에 닫는 괄호가 참조)
 *       - 결과 문자열에 번호 추가
 *    
 *    b. 닫는 괄호 ')' 발견:
 *       - 스택이 비어있으면 매칭 실패 (예외)
 *       - 스택 top()으로 짝이 맞는 여는 괄호의 번호 획득
 *       - 스택 pop()으로 해당 여는 괄호 제거
 *       - 결과 문자열에 같은 번호 추가
 *    
 *    c. 다른 문자:
 *       - 무시 (괄호만 처리)
 * 
 * [예시] 입력: "(a(b)c)"
 * 
 * 문자 '(': next_id=1, stack=[1], result="1"
 * 문자 'a': 무시
 * 문자 '(': next_id=2, stack=[1,2], result="1 2"
 * 문자 'b': 무시
 * 문자 ')': top=2, pop, stack=[1], result="1 2 2"
 * 문자 'c': 무시
 * 문자 ')': top=1, pop, stack=[], result="1 2 2 1"
 * 
 * [괄호 매칭 원리]
 * - 스택 LIFO 특성: 가장 최근 여는 괄호가 가장 먼저 닫힘
 * - 중첩된 괄호도 자연스럽게 처리됨
 */
string paren_count(string& ex_input) {
    Paren stack;
    int next_id = 0;        // 다음에 부여할 번호 (0에서 시작, 사용 시 ++로 1부터)
    string result;
    bool first = true;      // 첫 번째 출력인지 (공백 처리용)

    for (char ch : ex_input) {
        if (ch == '(') {
            // ============================================================
            // 여는 괄호: 새 번호 부여
            // ============================================================
            int id = ++next_id;     // 1, 2, 3, ... 순서로 번호 부여
            stack.push(id);         // 스택에 저장 (닫는 괄호가 참조할 예정)
            
            // 결과 문자열에 추가 (공백 구분)
            if (!first) result += ' ';
            result += to_string(id);
            first = false;
            
        } else if (ch == ')') {
            // ============================================================
            // 닫는 괄호: 짝이 맞는 여는 괄호의 번호 사용
            // ============================================================
            if (stack.empty()) throw runtime_error("Unmatched )");
            
            int id = stack.top();   // 가장 최근 여는 괄호의 번호
            stack.pop();            // 매칭 완료, 스택에서 제거
            
            // 결과 문자열에 같은 번호 추가
            if (!first) result += ' ';
            result += to_string(id);
            first = false;
        }
        // 다른 문자는 무시
    }
    return result;
}

/*
 * ============================================================================
 * main() - 프로그램 진입점
 * ============================================================================
 * 
 * [입력]
 * - 한 줄의 문자열 (괄호 포함)
 * 
 * [출력]
 * - 각 괄호의 번호를 공백으로 구분한 문자열
 * - 에러 발생 시 에러 메시지 출력
 */
int main() {
    string ex_input;
    getline(cin, ex_input);     // 공백 포함 전체 줄 입력
    
    try {
        cout << paren_count(ex_input) << endl;
    } catch (runtime_error& e) {
        cout << "Error: " << e.what() << endl;
    }
    return 0;
}
