/*
 * ============================================================================
 * prob01.cpp - BFS 기반 잔디 성장 시뮬레이션
 * ============================================================================
 * 
 * [문제 개요]
 * - N×N 격자에서 특정 위치에 잔디를 심으면, 매년 상하좌우로 퍼져나감
 * - 잔디는 빈 땅(LAND=0)에만 자랄 수 있고, 장애물(BLOCK=1)은 통과 불가
 * - MAX_YEAR 년이 지나면 더 이상 성장하지 않음
 * - 최종적으로 잔디가 덮은 총 칸 수와 각 칸에 잔디가 도달한 연도를 출력
 * 
 * [알고리즘]
 * - BFS(너비 우선 탐색)를 사용하여 동심원 형태로 잔디가 퍼져나가는 것을 시뮬레이션
 * - 큐에 현재 위치와 연도 정보를 저장하고, 인접한 빈 땅으로 확장
 * - 각 칸에 도달한 연도를 기록하여 시각화
 * 
 * [시간 복잡도] O(N²) - 각 칸을 최대 한 번씩 방문
 * [공간 복잡도] O(N²) - 격자 저장 및 BFS 큐
 */

#include <iostream>
#include <fstream>
#include <queue>
#include <vector>
using namespace std;

// ============================================================================
// 상수 정의
// ============================================================================
const int GRASS = -1;   // 잔디가 심어진 초기 위치를 표시 (나중에 0으로 변경됨)
const int BLOCK = 1;    // 장애물 - 잔디가 자랄 수 없는 칸
const int LAND  = 0;    // 빈 땅 - 잔디가 자랄 수 있는 칸

// ============================================================================
// 전역 변수
// ============================================================================
int N;                          // 격자의 크기 (N×N)
int MAX_YEAR;                   // 잔디가 성장할 수 있는 최대 연도
vector<vector<int>> ground;     // 격자 상태를 저장하는 2D 벡터

// ============================================================================
// 방향 오프셋 배열
// ============================================================================
// 상(북), 우(동), 하(남), 좌(서) 순서로 4방향 이동을 위한 좌표 변화량
// offset[dir][0] = x(행) 변화량, offset[dir][1] = y(열) 변화량
int offset[4][2] = {
    {-1, 0},    // 상 (위쪽): 행 감소
    {0, 1},     // 우 (오른쪽): 열 증가
    {1, 0},     // 하 (아래쪽): 행 증가
    {0, -1}     // 좌 (왼쪽): 열 감소
};

/*
 * ============================================================================
 * read_ground() - 파일에서 격자 데이터 읽기
 * ============================================================================
 * 
 * [기능]
 * - "input1.txt" 파일에서 격자 크기, 격자 데이터, 최대 연도를 읽어옴
 * 
 * [파일 형식]
 * - 첫 줄: N (격자 크기)
 * - 다음 N줄: 각 줄에 N개의 정수 (0: 빈 땅, 1: 장애물)
 * - 마지막 줄: MAX_YEAR (최대 성장 연도)
 */
void read_ground() {
    ifstream groundmap("input1.txt");

    groundmap >> N;
    
    // N×N 크기의 2D 벡터로 초기화
    ground.assign(N, vector<int>(N));

    // 격자 데이터 읽기
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            groundmap >> ground[i][j];
        }
    }

    groundmap >> MAX_YEAR;
    groundmap.close();
}

/*
 * ============================================================================
 * result() - 결과 격자 출력
 * ============================================================================
 * 
 * [매개변수]
 * - x, y: 잔디를 처음 심은 위치
 * 
 * [기능]
 * - 초기 심은 위치를 0으로 표시 (시작점)
 * - 전체 격자를 탭으로 구분하여 출력
 * - 각 칸의 값은 해당 칸에 잔디가 도달한 연도를 의미
 *   (1: 장애물, 음수 또는 양수: 잔디 도달 연도)
 */
void result(int x, int y) {
    ground[x][y] = 0;   // 초기 위치를 0으로 표시 (0년차에 심음)
    
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            cout << ground[i][j] << '\t';
        }
        cout << endl << endl;
    }
}

/*
 * ============================================================================
 * can_grow() - 특정 방향으로 잔디가 자랄 수 있는지 확인
 * ============================================================================
 * 
 * [매개변수]
 * - pos: 현재 잔디 위치 (pair<int,int>)
 * - dir: 확인할 방향 (0: 상, 1: 우, 2: 하, 3: 좌)
 * - year: 현재 연도
 * 
 * [반환값]
 * - true: 해당 방향으로 잔디가 자랄 수 있음
 * - false: 자랄 수 없음 (범위 밖, 장애물, 이미 잔디 있음, 최대 연도 초과)
 * 
 * [확인 조건]
 * 1. 아직 최대 연도에 도달하지 않았는지
 * 2. 이동할 위치가 격자 범위 내인지
 * 3. 이동할 위치가 빈 땅(LAND)인지
 */
bool can_grow(pair<int,int> &pos, int dir, int year) {
    // 최대 연도에 도달했으면 더 이상 성장 불가
    if (year >= MAX_YEAR) return false;

    // 이동할 위치 계산
    int x = pos.first  + offset[dir][0];
    int y = pos.second + offset[dir][1];

    // 범위 체크 및 빈 땅 확인
    return (x >= 0 && y >= 0 && x < N && y < N && ground[x][y] == LAND);
}

/*
 * ============================================================================
 * grow_to() - 특정 방향으로 이동한 새 위치 반환
 * ============================================================================
 * 
 * [매개변수]
 * - pos: 현재 위치
 * - dir: 이동 방향
 * 
 * [반환값]
 * - 이동 후의 새로운 위치 (pair<int,int>)
 * 
 * [참고]
 * - can_grow()로 이동 가능 여부를 먼저 확인한 후 호출해야 함
 */
pair<int,int> grow_to(pair<int,int> &pos, int dir) {
    return pair<int,int>(pos.first + offset[dir][0], pos.second + offset[dir][1]);
}

/*
 * ============================================================================
 * Status 구조체 - BFS에서 사용할 상태 정보
 * ============================================================================
 * 
 * [멤버]
 * - x, y: 현재 잔디 위치
 * - year: 이 위치에 잔디가 도달한 연도
 */
struct Status{
    int x;
    int y;
    int year;
};

/*
 * ============================================================================
 * countGrass() - BFS로 잔디 성장 시뮬레이션 및 총 잔디 수 계산
 * ============================================================================
 * 
 * [매개변수]
 * - x, y: 잔디를 처음 심는 위치
 * 
 * [반환값]
 * - 잔디가 덮은 총 칸 수
 * 
 * [알고리즘 상세]
 * 1. 시작 위치를 큐에 넣고 GRASS로 표시
 * 2. 큐에서 하나씩 꺼내며:
 *    a. 4방향으로 성장 가능 여부 확인
 *    b. 성장 가능하면 해당 칸에 (현재 연도 + 1) 기록
 *    c. 새 위치를 큐에 추가
 * 3. 큐가 빌 때까지 반복
 * 
 * [BFS 선택 이유]
 * - 동심원 형태로 퍼져나가는 현상을 자연스럽게 시뮬레이션
 * - 같은 연도에 도달하는 칸들이 함께 처리됨 (레벨 순회)
 */
int countGrass(int x, int y) {
    queue<Status> grass;
    
    // 초기 위치 설정
    grass.push({x, y, 0});      // 0년차에 시작
    ground[x][y] = GRASS;       // 시작 위치 표시
    int total_grass = 1;        // 시작 위치도 잔디 1칸으로 카운트

    while (!grass.empty()) {
        Status cur = grass.front();
        grass.pop();

        // 현재 위치를 pair로 변환 (can_grow, grow_to 함수용)
        pair<int,int> cur_pos(cur.x, cur.y);
        
        // 4방향으로 성장 시도
        for (int dir = 0; dir < 4; dir++) {
            if (can_grow(cur_pos, dir, cur.year)) {
                // 성장 가능한 새 위치 계산
                pair<int,int> nx = grow_to(cur_pos, dir);
                
                // 해당 칸에 도달 연도 기록 (방문 표시 역할도 함)
                ground[nx.first][nx.second] = cur.year + 1;
                
                // 큐에 추가하여 다음 턴에 이 위치에서 계속 성장
                grass.push({nx.first, nx.second, cur.year + 1});
                
                total_grass++;  // 잔디 칸 수 증가
            }
        }
    }

    return total_grass;
}

/*
 * ============================================================================
 * main() - 프로그램 진입점
 * ============================================================================
 * 
 * [실행 흐름]
 * 1. 파일에서 격자 데이터 읽기
 * 2. 사용자로부터 잔디 심을 위치 입력받기
 * 3. BFS로 잔디 성장 시뮬레이션 실행
 * 4. 총 잔디 칸 수와 최종 격자 상태 출력
 */
int main(void) {
    read_ground();

    int x, y;
    cin >> x >> y;      // 잔디 심을 위치 입력

    cout << countGrass(x, y) << endl;   // 총 잔디 수 출력
    result(x, y);                        // 격자 상태 출력

    return 0;
}
