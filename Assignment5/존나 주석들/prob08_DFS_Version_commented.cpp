/*
 * ============================================================================
 * prob08_DFS_Version.cpp - DFS를 이용한 장기 '포' 이동 가능 여부 판별
 * ============================================================================
 * 
 * [문제 개요]
 * - prob08.cpp와 동일한 문제
 * - N×N 장기판에서 '포'가 시작 위치에서 목표 위치까지 이동 가능한지 판별
 * - 이 버전은 BFS 대신 재귀 DFS로 구현
 * 
 * [포의 이동 규칙]
 * 1. 포는 가로/세로 방향으로만 이동 가능
 * 2. 반드시 정확히 하나의 말(장애물)을 뛰어넘어야 함
 * 3. 뛰어넘은 후 두 번째 장애물을 만나기 전까지의 빈 칸에 착지 가능
 * 
 * [BFS vs DFS 비교]
 * - BFS: 최단 경로 보장, 반복문 기반, 큐 사용
 * - DFS: 최단 경로 비보장, 재귀 기반, 스택(호출 스택) 사용
 * - 이 문제는 도달 가능 여부만 판별하므로 둘 다 사용 가능
 * 
 * [DFS 특징]
 * - 한 경로를 끝까지 탐색한 후 다른 경로 탐색
 * - 재귀적 구현이 직관적
 * - 목표 발견 시 즉시 반환하여 조기 종료 가능
 * 
 * [시간 복잡도] O(N² × N) = O(N³)
 * [공간 복잡도] O(N²) - 방문 배열 + 재귀 스택
 */

#include <iostream>
#include <fstream>
#include <vector>
using namespace std;

// ============================================================================
// 상수 정의
// ============================================================================
const int MAX = 16;         // 장기판 최대 크기
const int EMPTY = 0;        // 빈 칸 (이동 가능한 공간)
const int OCCUPIED = 1;     // 다른 말이 있는 칸 (장애물)

/*
 * ============================================================================
 * Position 구조체 - 장기판 위의 위치
 * ============================================================================
 */
struct Position {
    int x, y;
    Position() = default;
    Position(int x, int y) : x(x), y(y) {}
};

// ============================================================================
// 전역 변수
// ============================================================================
int N;                          // 보드 크기
int board[MAX][MAX];            // 장기판 상태
bool visited[MAX][MAX];         // DFS 방문 여부
Position start_pos, goal_pos;   // 시작/목표 위치

// ============================================================================
// 방향 오프셋 배열
// ============================================================================
// 북(상), 동(우), 남(하), 서(좌) 순서
int offset[4][2] = {
    {-1, 0},    // 북 (위)
    {0, 1},     // 동 (오른쪽)
    {1, 0},     // 남 (아래)
    {0, -1}     // 서 (왼쪽)
};

/*
 * ============================================================================
 * read_board() - 파일에서 장기판 데이터 읽기
 * ============================================================================
 * 
 * [파일 형식] input8.txt
 * - 첫 줄: N (장기판 크기)
 * - 다음 N줄: N×N 장기판 (0: 빈 칸, 1: 말 있음)
 * - 다음 줄: start_pos.x start_pos.y (시작 위치)
 * - 마지막 줄: goal_pos.x goal_pos.y (목표 위치)
 */
void read_board() {
    ifstream fin("input8.txt");
    fin >> N;
    
    // 보드 N×N 읽기
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            fin >> board[i][j];
        }
    }
    
    // 시작 좌표, 도착 좌표 읽기
    fin >> start_pos.x >> start_pos.y;
    fin >> goal_pos.x >> goal_pos.y;
    fin.close();
}

/*
 * ============================================================================
 * in_range() - 좌표가 장기판 범위 내인지 확인
 * ============================================================================
 */
bool in_range(int x, int y) {
    return x >= 0 && x < N && y >= 0 && y < N;
}

/*
 * ============================================================================
 * get_cannon_moves() - 포의 착지 가능 위치 계산
 * ============================================================================
 * 
 * [매개변수]
 * - cur: 현재 포의 위치
 * - dir: 이동 방향 (0: 북, 1: 동, 2: 남, 3: 서)
 * - destinations: 착지 가능한 위치들을 저장할 벡터 (출력 파라미터)
 * 
 * [알고리즘]
 * prob08.cpp의 can_moves()와 동일한 로직
 * 
 * [1단계] 첫 번째 장애물 찾기
 * - 빈 칸을 지나면서 첫 번째 말(OCCUPIED)을 찾음
 * - 뛰어넘을 말이 없으면 이동 불가
 * 
 * [2단계] 착지 가능 위치 수집
 * - 첫 번째 장애물 이후, 두 번째 장애물 전까지의 빈 칸들
 */
void get_cannon_moves(Position cur, int dir, vector<Position>& destinations) {
    int dx = offset[dir][0];
    int dy = offset[dir][1];
    
    int nx = cur.x + dx;
    int ny = cur.y + dy;
    
    // [1단계] 첫 번째 장애물(OCCUPIED)을 찾을 때까지 빈 칸을 지나감
    // 포는 반드시 하나의 말을 건너뛰어야 이동 가능
    while (in_range(nx, ny) && board[nx][ny] == EMPTY) {
        nx += dx;
        ny += dy;
    }
    
    // 범위를 벗어났거나 장애물을 찾지 못한 경우 이동 불가
    if (!in_range(nx, ny) || board[nx][ny] != OCCUPIED) {
        return;
    }
    
    // [2단계] 장애물을 건너뛴 후, 두 번째 장애물을 만나기 전까지의
    // 모든 빈 칸이 착지 가능한 위치
    nx += dx;
    ny += dy;
    
    while (in_range(nx, ny) && board[nx][ny] == EMPTY) {
        destinations.push_back(Position(nx, ny));
        nx += dx;
        ny += dy;
    }
}

/*
 * ============================================================================
 * init_visited() - 방문 배열 초기화
 * ============================================================================
 */
void init_visited() {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            visited[i][j] = false;
        }
    }
}

/*
 * ============================================================================
 * dfs_recursive() - 재귀 DFS로 목표 위치 도달 가능 여부 탐색
 * ============================================================================
 * 
 * [매개변수]
 * - cur: 현재 포의 위치
 * 
 * [반환값]
 * - true: 현재 위치에서 목표 위치까지 도달 가능
 * - false: 도달 불가능
 * 
 * [알고리즘 상세]
 * 
 * 1. 목표 도달 확인:
 *    - cur == goal_pos이면 즉시 true 반환
 * 
 * 2. 4방향 탐색:
 *    a. 각 방향으로 get_cannon_moves() 호출
 *    b. 착지 가능한 각 위치에 대해:
 *       - 미방문이면 방문 처리
 *       - 재귀 호출로 그 위치에서 탐색 계속
 *       - true가 반환되면 즉시 true 반환 (조기 종료)
 * 
 * 3. 모든 방향 탐색 실패:
 *    - false 반환
 * 
 * [DFS vs BFS 차이점]
 * - DFS: 한 경로를 끝까지 탐색 후 백트래킹
 * - 이 코드에서는 백트래킹 시 visited를 해제하지 않음
 *   → 도달 가능 여부만 판별하므로 재방문 불필요
 *   → 한 번 방문한 칸에서 목표에 도달 못하면, 
 *      다른 경로로 그 칸에 와도 마찬가지
 * 
 * [백트래킹 미사용 이유]
 * - 목표: "도달 가능 여부"만 판별
 * - 어떤 칸 X에서 목표에 도달할 수 없다면,
 *   다른 경로로 X에 도달해도 여전히 목표에 도달 불가
 * - 따라서 visited 해제 없이도 정확한 결과
 * - 만약 "모든 경로"나 "경로 개수"를 구한다면 백트래킹 필요
 */
bool dfs_recursive(Position cur) {
    // 목표 위치 도달 시 성공
    if (cur.x == goal_pos.x && cur.y == goal_pos.y) {
        return true;
    }
    
    // 네 방향으로 포 이동 시도
    for (int dir = 0; dir < 4; dir++) {
        vector<Position> destinations;
        get_cannon_moves(cur, dir, destinations);
        
        // 해당 방향으로 착지 가능한 모든 위치 탐색
        for (int i = 0; i < destinations.size(); i++) {
            Position next = destinations[i];
            
            // 미방문 위치면 재귀 호출
            if (!visited[next.x][next.y]) {
                visited[next.x][next.y] = true;
                
                // 재귀 호출로 목표 도달 성공 시 즉시 반환
                // (조기 종료로 불필요한 탐색 방지)
                if (dfs_recursive(next)) {
                    return true;
                }
                
                // 참고: 여기서 visited[next.x][next.y] = false; 를
                // 하지 않음 (백트래킹 미사용)
                // 이유: 도달 여부만 판별하므로 재방문 불필요
            }
        }
    }
    
    // 이 경로로는 목표 도달 불가
    return false;
}

/*
 * ============================================================================
 * main() - 프로그램 진입점
 * ============================================================================
 * 
 * [실행 흐름]
 * 1. 파일에서 보드 읽기
 * 2. 방문 배열 초기화
 * 3. 시작 위치 방문 처리
 * 4. 재귀 DFS로 탐색
 * 5. 결과 출력
 */
int main() {
    // 파일에서 보드 읽기
    read_board();
    
    // 방문 배열 초기화 및 시작 위치 방문 처리
    init_visited();
    visited[start_pos.x][start_pos.y] = true;
    
    // 재귀 DFS로 경로 탐색 후 결과 출력
    if (dfs_recursive(start_pos)) {
        cout << "Yes" << endl;
    } else {
        cout << "No" << endl;
    }
    
    return 0;
}
