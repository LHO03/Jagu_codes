/*
 * ============================================================================
 * prob03.cpp - 투 포인터(Two Pointer) 기반 합이 K인 쌍 개수 찾기
 * ============================================================================
 * 
 * [문제 개요]
 * - 정렬된 배열에서 두 원소의 합이 K가 되는 쌍의 개수를 찾음
 * - 같은 원소를 두 번 사용할 수 없음
 * 
 * [알고리즘]
 * - 투 포인터(Two Pointer) 기법을 재귀적으로 구현
 * - 배열이 정렬되어 있다는 점을 활용
 * - 양 끝에서 시작하여 중앙으로 좁혀가며 탐색
 * 
 * [투 포인터 원리]
 * - 정렬된 배열에서 두 포인터 start, end를 양 끝에 배치
 * - sum = arr[start] + arr[end]
 *   - sum == K: 쌍 발견! 양쪽 모두 이동
 *   - sum < K: 합이 작으므로 start를 증가 (더 큰 값 선택)
 *   - sum > K: 합이 크므로 end를 감소 (더 작은 값 선택)
 * 
 * [시간 복잡도] O(N) - 각 원소를 최대 한 번씩만 방문
 * [공간 복잡도] O(N) - 재귀 호출 스택 (반복문으로 O(1) 가능)
 * 
 * [전제 조건]
 * - 입력 배열이 오름차순으로 정렬되어 있어야 함
 */

#include <iostream>
using namespace std;

const int MAX = 1000;   // 배열 최대 크기
int ignite[MAX];        // 정렬된 입력 배열

/*
 * ============================================================================
 * two_someplace() - 재귀적 투 포인터로 합이 K인 쌍 개수 계산
 * ============================================================================
 * 
 * [매개변수]
 * - start: 왼쪽 포인터 (배열의 시작 쪽)
 * - end: 오른쪽 포인터 (배열의 끝 쪽)
 * - K: 목표 합
 * 
 * [반환값]
 * - start~end 범위에서 합이 K가 되는 쌍의 개수
 * 
 * [동작 원리]
 * 
 * 1. 종료 조건: start >= end
 *    - 두 포인터가 만나거나 교차하면 탐색 종료
 *    - 더 이상 쌍을 만들 수 없음
 * 
 * 2. 경우 1: ignite[start] + ignite[end] == K
 *    - 합이 정확히 K인 쌍 발견
 *    - 1을 더하고, 양쪽 포인터 모두 이동
 *    - start+1, end-1로 재귀 호출
 * 
 * 3. 경우 2: ignite[start] + ignite[end] < K
 *    - 합이 K보다 작음
 *    - 더 큰 합이 필요하므로 start를 증가 (더 큰 값 선택)
 *    - 배열이 정렬되어 있으므로 start++ 하면 합이 증가
 * 
 * 4. 경우 3: ignite[start] + ignite[end] > K
 *    - 합이 K보다 큼
 *    - 더 작은 합이 필요하므로 end를 감소 (더 작은 값 선택)
 *    - 배열이 정렬되어 있으므로 end-- 하면 합이 감소
 * 
 * [예시] 배열 = [1, 2, 3, 4, 5, 6], K = 7
 * 
 * - (1, 6): 1+6=7 ✓ → 쌍 발견, start++, end--
 * - (2, 5): 2+5=7 ✓ → 쌍 발견, start++, end--
 * - (3, 4): 3+4=7 ✓ → 쌍 발견, start++, end--
 * - start >= end → 종료
 * - 결과: 3쌍
 */
int two_someplace(int start, int end, int K){
    // 기저 조건: 포인터가 만나거나 교차하면 종료
    if (start >= end) return 0;

    // 두 원소의 합 비교
    if (ignite[start] + ignite[end] == K){
        // 합이 K와 같음 → 쌍 발견
        // 양쪽 포인터 모두 이동하여 다음 쌍 탐색
        return 1 + two_someplace(start + 1, end - 1, K);   
    } 
    
    if (ignite[start] + ignite[end] < K){
        // 합이 K보다 작음 → 더 큰 값이 필요
        // start를 증가시켜 더 큰 원소 선택
        return two_someplace(start + 1, end, K);
    } 
    else {
        // 합이 K보다 큼 → 더 작은 값이 필요
        // end를 감소시켜 더 작은 원소 선택
        return two_someplace(start, end - 1, K);
    }
}

/*
 * ============================================================================
 * main() - 프로그램 진입점
 * ============================================================================
 * 
 * [입력 형식]
 * - 첫 줄: N (배열 크기)
 * - 둘째 줄: N개의 정수 (오름차순 정렬되어 있어야 함)
 * - 셋째 줄: K (목표 합)
 * 
 * [출력]
 * - 합이 K가 되는 쌍의 개수
 */
int main(void){
    int N, K;
    
    cin >> N;
    for (int i = 0; i < N; i++){
        cin >> ignite[i];
    }
    cin >> K;
    
    // 배열 전체 범위(0 ~ N-1)에서 합이 K인 쌍 개수 출력
    cout << two_someplace(0, N - 1, K);
    
    return 0;
}
