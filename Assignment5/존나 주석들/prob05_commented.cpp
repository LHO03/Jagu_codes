/*
 * ============================================================================
 * prob05.cpp - DFS 백트래킹을 이용한 미로 경로 개수 세기
 * ============================================================================
 * 
 * [문제 개요]
 * - N×N 미로에서 (0,0)부터 (N-1,N-1)까지 갈 수 있는
 *   서로 다른 경로의 총 개수를 구함
 * - 같은 칸을 두 번 지나는 것은 허용되지 않음
 * 
 * [알고리즘]
 * - DFS(깊이 우선 탐색) + 백트래킹
 * - 모든 가능한 경로를 완전 탐색
 * - 방문한 칸은 표시하고, 탐색 후 해제하여 다른 경로에서 재사용
 * 
 * [백트래킹 핵심]
 * - 한 경로를 끝까지 탐색 후 되돌아올 때
 * - 방문 표시를 해제해야 다른 경로에서 같은 칸을 사용 가능
 * - 이것이 "모든 경로"를 찾는 핵심
 * 
 * [시간 복잡도] O(4^(N²)) 최악의 경우 - 모든 경로 탐색
 * [공간 복잡도] O(N²) - 방문 배열 + 재귀 스택
 */

#include <iostream>
#include <fstream>
using namespace std;

// ============================================================================
// 상수 및 전역 변수
// ============================================================================
const int MAX_N = 100;  // 미로 최대 크기
const int PATH = 0;     // 이동 가능한 길
const int WALL = 1;     // 벽 (이동 불가)

int n;                          // 미로 크기
int maze[MAX_N][MAX_N];         // 미로 데이터
bool visited[MAX_N][MAX_N];     // 방문 여부 배열

/*
 * ============================================================================
 * read_maze() - 파일에서 미로 데이터 읽기
 * ============================================================================
 * 
 * [파일 형식] maze.txt
 * - 첫 줄: n (미로 크기)
 * - 다음 n줄: 각 줄에 n개의 정수 (0: 길, 1: 벽)
 */
void read_maze(){
    ifstream maze_file("maze.txt");
    
    maze_file >> n;
    for (int i = 0; i < n; i++){
        for (int j = 0; j < n; j++){
            maze_file >> maze[i][j];
        }
    }

    maze_file.close();
}

// ============================================================================
// 방향 오프셋 배열
// ============================================================================
// 상(북), 우(동), 하(남), 좌(서) 순서
int offset[4][2] = {
    {-1, 0},    // 상
    {0, 1},     // 우
    {1, 0},     // 하
    {0, -1}     // 좌
};

/*
 * ============================================================================
 * dfs() - 재귀 DFS로 목적지까지의 경로 수 계산
 * ============================================================================
 * 
 * [매개변수]
 * - x, y: 현재 위치
 * 
 * [반환값]
 * - 현재 위치에서 목적지(n-1, n-1)까지 갈 수 있는 경로의 수
 * 
 * [알고리즘 상세]
 * 
 * 1. 유효성 검사 (실패 조건들):
 *    - 범위 밖: x < 0, x >= n, y < 0, y >= n
 *    - 벽: maze[x][y] == WALL
 *    - 이미 방문: visited[x][y] == true
 *    → 이 경우 0 반환 (이 방향으로는 경로 없음)
 * 
 * 2. 목적지 도달 확인:
 *    - (x, y) == (n-1, n-1)이면 1 반환
 *    - 유효한 경로 하나를 찾음!
 * 
 * 3. 방문 표시:
 *    - visited[x][y] = true
 *    - 현재 경로에서 이 칸을 사용 중임을 표시
 * 
 * 4. 4방향 재귀 탐색:
 *    - 각 방향으로 dfs 호출
 *    - 반환값들을 모두 합산 (모든 방향의 경로 수)
 * 
 * 5. 백트래킹 (방문 해제):
 *    - visited[x][y] = false
 *    - 이 칸을 다른 경로에서 다시 사용할 수 있도록 해제
 *    - ★ 이것이 "모든 경로"를 찾는 핵심! ★
 * 
 * [백트래킹 시각화 예시]
 * 
 *    S → A → B → E (목적지)  경로 1 발견!
 *              ↓
 *         백트래킹: B 해제
 *              ↓
 *    S → A → C → E (목적지)  경로 2 발견!
 *              ↓
 *         백트래킹: A, C 해제
 *              ↓
 *    S → D → E (목적지)      경로 3 발견!
 * 
 * [왜 백트래킹이 필요한가?]
 * - 일반적인 DFS (최단 경로, 연결성 확인)에서는 방문 해제 불필요
 * - 하지만 "모든 경로"를 찾으려면, 한 경로에서 사용한 칸을
 *   다른 경로에서도 사용할 수 있어야 함
 * - 같은 칸이라도 다른 경로의 일부가 될 수 있음
 */
int dfs(int x, int y){
    // ================================================================
    // 유효성 검사
    // ================================================================
    // 범위 밖, 벽, 또는 이미 방문한 칸이면 이 방향은 막다른 길
    if (x < 0 || x >= n || y < 0 || y >= n || 
        maze[x][y] == WALL || visited[x][y]) {
        return 0;
    }

    // ================================================================
    // 목적지 도달
    // ================================================================
    // 목적지에 도착하면 유효한 경로 하나를 찾은 것
    if (x == n - 1 && y == n - 1) {
        return 1;
    }
    
    // ================================================================
    // 방문 표시
    // ================================================================
    // 현재 칸을 현재 경로에서 사용 중으로 표시
    visited[x][y] = true;
    
    // ================================================================
    // 4방향 재귀 탐색
    // ================================================================
    // 네 방향으로 탐색하며 각 방향에서 찾은 경로 수를 합산
    int count = 0;
    for (int dir = 0; dir < 4; dir++) {
        int nx = x + offset[dir][0];
        int ny = y + offset[dir][1];
        count += dfs(nx, ny);   // 각 방향의 경로 수 누적
    }
    
    // ================================================================
    // 백트래킹: 방문 표시 해제
    // ================================================================
    // ★ 핵심: 다른 경로 탐색을 위해 방문 표시를 해제
    // 이렇게 해야 이 칸이 다른 경로의 일부가 될 수 있음
    visited[x][y] = false;
    
    return count;
}

/*
 * ============================================================================
 * main() - 프로그램 진입점
 * ============================================================================
 * 
 * [실행 흐름]
 * 1. 파일에서 미로 읽기
 * 2. (0,0)에서 DFS 시작
 * 3. 찾은 경로의 총 개수 출력
 */
int main(){
    read_maze();

    // (0,0)에서 시작하여 (n-1, n-1)까지의 모든 경로 수 계산
    int answer = dfs(0, 0);
    cout << answer << '\n';
    
    return 0;
}
