/*
 * ============================================================================
 * prob02.cpp - 스택을 이용한 "보이는 건물" 개수 계산
 * ============================================================================
 * 
 * [문제 개요]
 * - 오른쪽에서 왼쪽으로 건물들을 바라볼 때
 * - 각 건물이 추가될 때마다 "보이는 건물"의 개수를 출력
 * - 높이가 같거나 낮은 건물은 더 높은 건물에 가려져 보이지 않음
 * 
 * [핵심 아이디어]
 * - 새 건물이 들어올 때, 그 건물보다 낮거나 같은 건물은 가려짐
 * - 스택에는 "아직 가려지지 않은 건물들"의 높이만 유지
 * - 스택의 크기 = 현재 보이는 건물 수
 * 
 * [예시]
 * 건물 높이: [3, 1, 4, 1, 5, 9, 2, 6]
 * 
 * 3 입력: stack=[3], 보이는 건물=1
 * 1 입력: stack=[3,1], 보이는 건물=2 (1은 3보다 낮으므로 유지)
 * 4 입력: 3,1 모두 제거, stack=[4], 보이는 건물=1
 * 1 입력: stack=[4,1], 보이는 건물=2
 * 5 입력: 4,1 모두 제거, stack=[5], 보이는 건물=1
 * 9 입력: 5 제거, stack=[9], 보이는 건물=1
 * 2 입력: stack=[9,2], 보이는 건물=2
 * 6 입력: 2 제거, stack=[9,6], 보이는 건물=2
 * 
 * [알고리즘]
 * - Monotonic Stack (단조 스택) 변형
 * - 스택에는 내림차순으로 높이가 유지됨 (top이 가장 작음)
 * - 새 건물이 스택 top보다 크면, top을 제거 (가려짐)
 * 
 * [시간 복잡도] O(N) - 각 원소는 최대 한 번 push, 한 번 pop
 * [공간 복잡도] O(N) - 스택 크기
 */

#include <iostream>
using namespace std;

const int MAX_CAPACITY = 100;   // 스택 최대 용량

/*
 * ============================================================================
 * Stack 클래스 - 정수를 저장하는 배열 기반 스택
 * ============================================================================
 * 
 * [용도]
 * - 현재까지 "보이는" 건물들의 높이를 저장
 * - 내림차순 유지 (bottom이 가장 크고, top이 가장 작음)
 */
class Stack{
public:
    int nums[MAX_CAPACITY];     // 건물 높이 저장 배열
    int count = 0;              // 현재 원소 수

    /*
     * empty() - 스택이 비어있는지 확인
     */
    bool empty() { return count == 0; }
    
    /*
     * full() - 스택이 가득 찼는지 확인
     */
    bool full() { return count == MAX_CAPACITY; }
    
    /*
     * push(x) - 스택에 원소 추가
     * 매개변수: x - 건물 높이
     */
    void push(int x){
        if (full()) throw runtime_error("Full");
        nums[count++] = x;
    }
    
    /*
     * pop() - 스택에서 원소 제거
     * 용도: 새 건물에 가려지는 건물 제거
     */
    void pop(){
        if (empty()) throw runtime_error("Pop_Empty");
        count--;
    }
    
    /*
     * top() - 스택의 최상위 원소 반환
     * 반환: 현재 보이는 건물 중 가장 낮은 건물의 높이
     */
    int top(){
        if (empty()) throw runtime_error("Top_Empty");
        return nums[count - 1];
    }
    
    /*
     * size() - 현재 스택 크기 반환
     * 반환: 현재 보이는 건물의 개수
     */
    int size(){
        return count;
    }
};

/*
 * ============================================================================
 * main() - 프로그램 진입점
 * ============================================================================
 * 
 * [알고리즘 상세]
 * 
 * 각 건물이 입력될 때마다:
 * 
 * 1. while 루프: 스택 top <= 새 건물 높이
 *    - 스택 top의 건물은 새 건물에 가려짐
 *    - pop()으로 제거
 *    - 반복하여 모든 가려지는 건물 제거
 * 
 * 2. push: 새 건물을 스택에 추가
 *    - 이제 스택에는 새 건물보다 큰 건물들만 남아있음
 *    - 새 건물은 그 뒤에 추가됨
 * 
 * 3. size() 출력: 현재 보이는 건물 수
 * 
 * [단조 스택 특성]
 * - 스택은 항상 내림차순 유지 (strict하게 감소)
 * - nums[0] > nums[1] > ... > nums[count-1]
 * - 이 특성 덕분에 top보다 큰 건물이 오면 연속으로 pop 가능
 * 
 * [예시 트레이스] 입력: [5, 3, 4, 2]
 * 
 * num=5: stack=[], top 없음 → push(5), stack=[5], size=1
 * num=3: stack=[5], top=5 > 3 → push(3), stack=[5,3], size=2
 * num=4: stack=[5,3], top=3 <= 4 → pop, stack=[5]
 *        stack=[5], top=5 > 4 → push(4), stack=[5,4], size=2
 * num=2: stack=[5,4], top=4 > 2 → push(2), stack=[5,4,2], size=3
 * 
 * [입력 형식]
 * - 첫 줄: n (건물 개수)
 * - 다음 n개의 정수: 각 건물의 높이
 * 
 * [출력]
 * - 각 건물이 추가될 때마다 현재 보이는 건물 수
 */
int main(void){
    int n;
    cin >> n;

    int num;
    Stack nums;
    
    for (int i = 0; i < n; i++){
        cin >> num;
        
        // ================================================================
        // 새 건물에 가려지는 건물들 제거
        // ================================================================
        // 스택 top이 새 건물보다 작거나 같으면 가려짐
        // 조건: top() <= num (같은 높이도 가려진다고 처리)
        while(!nums.empty() && nums.top() <= num) {
            nums.pop();
        }

        // ================================================================
        // 새 건물 추가
        // ================================================================
        nums.push(num);
        
        // ================================================================
        // 현재 보이는 건물 수 출력
        // ================================================================
        cout << nums.size() << " " << endl;
    }    
    return 0;
}
