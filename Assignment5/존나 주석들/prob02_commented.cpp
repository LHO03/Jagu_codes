/*
 * ============================================================================
 * prob02.cpp - 스택 기반 미로 탐색 (최소 방향 전환 횟수)
 * ============================================================================
 * 
 * [문제 개요]
 * - N×N 미로에서 (0,0)부터 (N-1,N-1)까지 이동
 * - 목표: 방향을 바꾸는 횟수(꺾임)를 최소화
 * - 0은 이동 가능한 길, 1은 벽
 * 
 * [알고리즘]
 * - 스택을 이용한 DFS 변형 + 백트래킹
 * - 모든 경로를 탐색하되, 가지치기(pruning)로 효율성 확보
 * - 현재까지 찾은 최솟값보다 큰 경로는 탐색 중단
 * 
 * [핵심 아이디어]
 * - 같은 방향으로 계속 이동하면 count 유지
 * - 방향이 바뀌면 count + 1
 * - 백트래킹을 위해 "복원용 마커"를 스택에 함께 저장
 * 
 * [시간 복잡도] O(4^(N²)) 최악의 경우, 가지치기로 실제로는 훨씬 빠름
 */

#include <iostream>
#include <fstream>
#include <stack>
#include <vector>
using namespace std;

// ============================================================================
// 상수 정의
// ============================================================================
const int PATH = 0;         // 이동 가능한 길
const int WALL = 1;         // 벽 (이동 불가)
const int VISITED = 2;      // 방문한 칸 (현재 경로에서 사용 중)
const int BACKTRACKED = 3;  // 백트래킹됨 (사용되지 않음, 확장용)

// ============================================================================
// 전역 변수
// ============================================================================
int N;                      // 미로 크기
vector<vector<int>> maze;   // 미로 데이터

/*
 * ============================================================================
 * read_maze() - 파일에서 미로 데이터 읽기
 * ============================================================================
 * 
 * [파일 형식] input2.txt
 * - 첫 줄: N (미로 크기)
 * - 다음 N줄: 각 줄에 N개의 정수 (0: 길, 1: 벽)
 */
void read_maze(){
    ifstream maze_map("input2.txt");

    maze_map >> N;
    maze.assign(N, vector<int>(N));

    for (int i = 0; i < N; i++){
        for (int j = 0; j < N; j++){
            maze_map >> maze[i][j];
        }
    }
    maze_map.close();
}

/*
 * ============================================================================
 * print_maze() - 미로 상태 출력 (디버깅용)
 * ============================================================================
 */
void print_maze(){
    for (int i = 0; i < N; i++){
        for (int j = 0; j < N; j++){
            cout << maze[i][j] << '\t';
        }
        cout << endl << endl;
    }
}

/*
 * ============================================================================
 * Status 클래스 - 탐색 상태 정보
 * ============================================================================
 * 
 * [멤버 변수]
 * - x, y: 현재 위치
 * - count: 현재까지의 방향 전환(꺾임) 횟수
 * - dir: 이 위치에 도달할 때의 이동 방향
 * - is_backtrack: true면 백트래킹용 마커 (방문 해제용)
 * 
 * [백트래킹 마커 설명]
 * - DFS에서 한 경로를 끝까지 탐색 후 되돌아올 때
 * - 방문 표시를 해제해야 다른 경로에서 같은 칸을 다시 방문 가능
 * - is_backtrack=true인 항목이 pop되면 해당 칸을 PATH로 복원
 */
class Status{
public:
    int x, y, count, dir;
    bool is_backtrack;  // 백트래킹 표시용
    
    Status() = default;
    Status(int x, int y, int c, int d, bool bt = false) 
        : x(x), y(y), count(c), dir(d), is_backtrack(bt) {}
};

// ============================================================================
// 방향 오프셋 배열
// ============================================================================
// 0: 상(북), 1: 우(동), 2: 하(남), 3: 좌(서)
int offset[4][2] = {
    {-1, 0},    // 상
    {0, 1},     // 우
    {1, 0},     // 하
    {0, -1}     // 좌
};

/*
 * ============================================================================
 * can_go() - 특정 위치로 이동 가능한지 확인
 * ============================================================================
 * 
 * [매개변수]
 * - x, y: 확인할 위치
 * 
 * [반환값]
 * - true: 범위 내이고 길(PATH)인 경우
 * - false: 범위 밖이거나 벽/방문한 칸인 경우
 */
bool can_go(int x, int y){
    return (x >= 0 && y >= 0 && x < N && y < N && maze[x][y] == PATH);
}

/*
 * ============================================================================
 * count_branch() - 최소 방향 전환 횟수 계산
 * ============================================================================
 * 
 * [반환값]
 * - 목적지까지의 최소 꺾임 횟수
 * - 경로가 없으면 0을 반환하고 "No path exists" 출력
 * 
 * [알고리즘 상세]
 * 
 * 1. 초기화
 *    - (0,0)을 방문 처리
 *    - (0,0)에서 갈 수 있는 방향을 모두 스택에 push
 * 
 * 2. 스택이 빌 때까지 반복:
 *    a. pop한 항목이 백트래킹 마커면:
 *       - 해당 칸을 PATH로 복원 (방문 해제)
 *       - continue
 *    
 *    b. 가지치기:
 *       - 현재 count가 이미 찾은 최솟값 이상이면 skip
 *    
 *    c. 방문 처리:
 *       - maze[x][y] = VISITED
 *    
 *    d. 목적지 도달 확인:
 *       - (N-1, N-1)이면 min_branch 갱신
 *       - 다른 경로 탐색을 위해 PATH로 복원
 *    
 *    e. 백트래킹 마커 push:
 *       - 현재 위치의 복원을 위해 is_backtrack=true인 Status push
 *    
 *    f. 4방향 탐색:
 *       - 이동 가능한 방향마다 새 Status를 스택에 push
 *       - 방향이 바뀌면 count + 1, 같으면 count 유지
 * 
 * [가지치기 효과]
 * - 이미 최적해보다 나쁜 경로는 더 탐색하지 않음
 * - 탐색 공간을 크게 줄여 효율성 향상
 */
int count_branch(){
    int min_branch = INT_MAX;   // 최소 꺾임 횟수 (초기값: 무한대)
    stack<Status> branch;       // DFS용 스택

    // 시작점 (0,0) 방문 처리
    maze[0][0] = VISITED;
    
    // 시작점에서 이동 가능한 방향을 스택에 추가
    // 시작점에서 첫 이동은 꺾임으로 치지 않음 (count = 0)
    for (int dir = 0; dir < 4; dir++){
        int nx = offset[dir][0];    // 0 + offset = offset
        int ny = offset[dir][1];
        if (can_go(nx, ny)) { 
            branch.push(Status(nx, ny, 0, dir, false)); 
        }
    }
    
    while(!branch.empty()){
        Status cur = branch.top();
        branch.pop();
        
        // ================================================================
        // 백트래킹 처리
        // ================================================================
        // 이 항목이 "복원용 마커"이면 해당 칸을 다시 PATH로 변경
        // 다른 경로에서 이 칸을 다시 방문할 수 있도록 함
        if (cur.is_backtrack){
            maze[cur.x][cur.y] = PATH;
            continue;
        }
        
        // ================================================================
        // 가지치기 (Pruning)
        // ================================================================
        // 현재까지의 꺾임 횟수가 이미 찾은 최솟값 이상이면
        // 이 경로를 더 탐색해도 더 좋은 결과가 나올 수 없음
        if (cur.count >= min_branch) continue;
        
        // ================================================================
        // 방문 표시
        // ================================================================
        maze[cur.x][cur.y] = VISITED;
        
        // ================================================================
        // 목적지 도달 확인
        // ================================================================
        if (cur.x == N - 1 && cur.y == N - 1){
            // 더 적은 꺾임으로 도달했으면 갱신
            min_branch = min(min_branch, cur.count);
            
            // 다른 경로 탐색을 위해 복원
            // (목적지에서는 백트래킹 마커를 push하지 않으므로 여기서 직접 복원)
            maze[cur.x][cur.y] = PATH;
            continue;
        }
        
        // ================================================================
        // 백트래킹 마커 push
        // ================================================================
        // 현재 칸에서 탐색이 끝나면 복원하기 위한 마커
        // 스택 특성상, 모든 자식 탐색이 끝난 후에 이 마커가 pop됨
        branch.push(Status(cur.x, cur.y, cur.count, cur.dir, true));
        
        // ================================================================
        // 4방향 탐색
        // ================================================================
        for (int next_dir = 0; next_dir < 4; next_dir++){
            int nx = cur.x + offset[next_dir][0];
            int ny = cur.y + offset[next_dir][1];
            
            if (!can_go(nx, ny)) continue;
            
            // 꺾임 계산: 이전 방향과 다르면 +1
            int new_count = cur.count + (cur.dir != next_dir ? 1 : 0);
            
            // 가지치기: 이미 최솟값 이상이면 push하지 않음
            if (new_count < min_branch) { 
                branch.push(Status(nx, ny, new_count, next_dir, false)); 
            }
        }
    }

    // ================================================================
    // 결과 출력
    // ================================================================
    if (min_branch == INT_MAX){
        cout << "No path exists";
        return 0;
    } else {
        cout << min_branch << '\n';
        return min_branch;
    }
}

/*
 * ============================================================================
 * main() - 프로그램 진입점
 * ============================================================================
 */
int main(){
    read_maze();
    count_branch();
    return 0;
}
