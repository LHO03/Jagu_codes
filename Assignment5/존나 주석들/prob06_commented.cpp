/*
 * ============================================================================
 * prob06.cpp - 해밍 거리가 K인 모든 이진 문자열 생성
 * ============================================================================
 * 
 * [문제 개요]
 * - 주어진 이진 문자열에서 정확히 K개의 비트를 뒤집어서
 *   만들 수 있는 모든 문자열을 출력
 * - 해밍 거리(Hamming Distance): 두 문자열에서 다른 위치의 개수
 * - 사전순(lexicographic order)으로 출력
 * 
 * [알고리즘]
 * - 백트래킹을 이용한 조합 생성
 * - 각 위치에서 "뒤집는다 / 뒤집지 않는다" 두 가지 선택
 * - 사전순 출력을 위해 "뒤집지 않는다"를 먼저 탐색
 * 
 * [핵심 아이디어]
 * - N개의 비트 중 K개를 선택하여 뒤집는 조합 문제 (nCk)
 * - 백트래킹으로 모든 조합을 탐색
 * - 가지치기로 불필요한 탐색 방지
 * 
 * [시간 복잡도] O(nCk × n) - 조합 수 × 출력
 * [공간 복잡도] O(n) - 재귀 스택 깊이
 */

#include <iostream>
#include <string>
using namespace std;

// ============================================================================
// 전역 변수
// ============================================================================
string s;   // 원본 이진 문자열 (변경되며 백트래킹으로 복원됨)
int N;      // 문자열 길이
int K;      // 뒤집어야 할 비트 수 (목표 해밍 거리)

/*
 * ============================================================================
 * binaryDistance() - 해밍 거리 K인 모든 문자열 생성
 * ============================================================================
 * 
 * [매개변수]
 * - pos: 현재 처리 중인 비트 위치 (0 ~ N-1)
 * - flipsLeft: 앞으로 더 뒤집어야 할 비트 개수
 * 
 * [동작 원리]
 * 
 * 1. 가지치기 (Pruning):
 *    a. flipsLeft < 0: 불가능한 상태 (이미 K개 초과로 뒤집음)
 *    b. N - pos < flipsLeft: 남은 위치보다 뒤집어야 할 개수가 많음
 *       → 더 탐색해도 K개를 채울 수 없음
 * 
 * 2. 종료 조건 (pos == N):
 *    - 모든 위치를 처리 완료
 *    - flipsLeft == 0이면 정확히 K개를 뒤집은 것 → 결과 출력
 *    - flipsLeft != 0이면 K개를 채우지 못함 → 출력 안 함
 * 
 * 3. 선택 1: 현재 위치를 뒤집지 않음
 *    - binaryDistance(pos + 1, flipsLeft)
 *    - ★ 사전순을 위해 이것을 먼저 탐색! ★
 *    - 뒤집지 않으면 해당 비트는 원본 유지
 * 
 * 4. 선택 2: 현재 위치를 뒤집음
 *    a. 비트 토글: '0' ↔ '1'
 *    b. 재귀 호출: binaryDistance(pos + 1, flipsLeft - 1)
 *    c. 백트래킹: 비트를 다시 토글하여 원상 복구
 * 
 * [사전순 보장 원리]
 * - 각 위치에서 "뒤집지 않는다"를 먼저 탐색
 * - 원본 비트가 유지되면 작은 인덱스일수록 원본 값 유지
 * - 예: "10"에서 K=1
 *   - 위치 0 뒤집음: "00" (먼저 탐색되지 않음)
 *   - 위치 0 유지 → 위치 1 뒤집음: "11"
 *   실제 순서: 위치 0 유지 먼저 → "1_"로 시작하는 것 탐색
 *              그 다음 위치 0 뒤집음 → "0_"로 시작하는 것 탐색
 *   → "00"이 "11"보다 먼저 출력됨
 * 
 * [예시] s = "00", K = 1
 * 
 * binaryDistance(0, 1)
 * ├─ pos=0 뒤집지 않음 → binaryDistance(1, 1)
 * │  ├─ pos=1 뒤집지 않음 → binaryDistance(2, 1)
 * │  │  └─ flipsLeft=1 ≠ 0 → 출력 안 함
 * │  └─ pos=1 뒤집음 "01" → binaryDistance(2, 0)
 * │     └─ flipsLeft=0 → 출력: "01"
 * │     └─ 백트래킹: "00"으로 복원
 * └─ pos=0 뒤집음 "10" → binaryDistance(1, 0)
 *    ├─ pos=1 뒤집지 않음 → binaryDistance(2, 0)
 *    │  └─ flipsLeft=0 → 출력: "10"
 *    └─ pos=1 뒤집음: N-pos(1) < flipsLeft(-1)? No, but flipsLeft=-1 < 0
 *       └─ 가지치기
 *    └─ 백트래킹: "00"으로 복원
 * 
 * 출력 순서: "01", "10" (사전순)
 */
void binaryDistance(int pos, int flipsLeft){
    // ================================================================
    // 가지치기: 불가능한 경우 조기 종료
    // ================================================================
    // 1. flipsLeft < 0: 이미 K개 초과로 뒤집음
    // 2. N - pos < flipsLeft: 남은 위치로는 필요한 수만큼 뒤집을 수 없음
    if (flipsLeft < 0 || (N - pos < flipsLeft)) {
        return;
    }
    
    // ================================================================
    // 종료 조건: 모든 위치 처리 완료
    // ================================================================
    if (pos == N) {
        // 정확히 K개를 뒤집은 경우에만 출력
        if (flipsLeft == 0) {
            cout << s << '\n';
        }
        return;
    }
    
    // ================================================================
    // 선택 1: 현재 위치를 뒤집지 않음 (먼저 탐색 → 사전순 보장)
    // ================================================================
    binaryDistance(pos + 1, flipsLeft);
    
    // ================================================================
    // 선택 2: 현재 위치를 뒤집음
    // ================================================================
    // 비트 토글: '0' → '1' 또는 '1' → '0'
    s[pos] = s[pos] == '0' ? '1' : '0';

    binaryDistance(pos + 1, flipsLeft - 1);
    
    // ================================================================
    // 백트래킹: 원상 복구
    // ================================================================
    // 다른 분기를 탐색하기 위해 원래 값으로 되돌림
    s[pos] = s[pos] == '0' ? '1' : '0';
}

/*
 * ============================================================================
 * main() - 프로그램 진입점
 * ============================================================================
 * 
 * [입력 형식]
 * - 첫 줄: 이진 문자열 s
 * - 둘째 줄: K (뒤집을 비트 수)
 * 
 * [출력]
 * - s에서 정확히 K개의 비트를 뒤집어 만들 수 있는 모든 문자열
 * - 사전순으로 출력
 */
int main(){   
    cin >> s >> K;
    N = (int)s.size();
    
    // 위치 0부터 시작, K개를 뒤집어야 함
    binaryDistance(0, K);
    
    return 0;
}
