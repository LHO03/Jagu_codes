/*
 * ============================================================================
 * test.cpp - 큐를 이용한 럭키 넘버(Lucky Number) 생성 및 판별
 * ============================================================================
 * 
 * [럭키 넘버란?]
 * - 에라토스테네스의 체와 유사한 방식으로 생성되는 수열
 * - 위치 기반으로 원소를 제거하여 생성
 * 
 * [생성 과정]
 * 1. 1부터 시작하는 홀수들: 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, ...
 * 2. 3의 배수 위치 제거: 1, 3, 7, 9, 13, 15, 19, 21, 25, ...
 *    (3번째=5, 6번째=11, 9번째=17, 12번째=23, ... 제거)
 * 3. 4의 배수 위치 제거: 1, 3, 7, 13, 15, 19, 25, ...
 *    (4번째=9, 8번째=21, ... 제거)
 * 4. 5의 배수 위치 제거, 6의 배수 위치 제거, ...
 * 5. 더 이상 제거할 것이 없을 때까지 반복
 * 
 * [prob07.cpp와의 차이]
 * - prob07.cpp: 재귀적으로 특정 숫자가 럭키 넘버인지 판별 (공간 효율적)
 * - test.cpp: 실제로 수열을 생성하여 저장 후 검색 (직관적, 메모리 사용)
 * 
 * [알고리즘]
 * - 큐를 이용하여 제거 과정을 시뮬레이션
 * - 각 단계에서 step의 배수 위치를 제거
 * - 최종적으로 남은 숫자들이 럭키 넘버
 * 
 * [시간 복잡도] O(n × √n) - 각 단계에서 O(n) 처리, 약 √n 단계
 * [공간 복잡도] O(n) - 모든 럭키 넘버 저장
 */

#include <iostream>
#include <queue>
#include <vector>
using namespace std;

/*
 * ============================================================================
 * generateLuckyNumbers() - maxN 이하의 모든 럭키 넘버 생성
 * ============================================================================
 * 
 * [매개변수]
 * - maxN: 생성할 럭키 넘버의 최대 범위
 * 
 * [반환값]
 * - maxN 이하의 모든 럭키 넘버를 담은 벡터
 * 
 * [알고리즘 상세]
 * 
 * [1단계] 홀수만 큐에 넣기
 * - 짝수(2, 4, 6, ...)는 2단계에서 모두 제거됨
 * - 처음부터 홀수만 넣어서 2단계를 생략
 * - 큐: [1, 3, 5, 7, 9, 11, 13, ...]
 * 
 * [2단계~] step = 3, 4, 5, ... 간격으로 제거
 * - 현재 수열의 크기만큼 반복
 * - 각 원소의 위치(pos)가 step의 배수면 제거
 * - 그렇지 않으면 큐의 뒤에 다시 추가
 * 
 * [큐 순환 기법]
 * - front()로 원소를 확인하고 pop()
 * - 유지할 원소는 push()로 뒤에 추가
 * - 한 바퀴 돌면 step의 배수 위치만 제거된 상태
 * 
 * [예시] step = 3 처리
 * 
 * 초기 큐: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, ...]
 * 위치:     1  2  3  4  5   6   7   8   9  10
 * 
 * pos=1: 1 → 3의 배수 아님 → 유지 (push)
 * pos=2: 3 → 3의 배수 아님 → 유지 (push)
 * pos=3: 5 → 3의 배수! → 제거 (push 안 함)
 * pos=4: 7 → 유지
 * pos=5: 9 → 유지
 * pos=6: 11 → 3의 배수! → 제거
 * ...
 * 
 * 결과 큐: [1, 3, 7, 9, 13, 15, 19, ...]
 * 
 * [종료 조건]
 * - step이 큐의 크기보다 커지면 종료
 * - 더 이상 제거될 원소가 없음
 */
vector<int> generateLuckyNumbers(int maxN) {
    // ================================================================
    // 1단계: 홀수만 큐에 넣기
    // ================================================================
    // 짝수는 이미 제거된 것으로 간주 (2의 배수 위치 = 짝수)
    queue<int> q;
    for (int i = 1; i <= maxN; i += 2) {
        q.push(i);      // 1, 3, 5, 7, 9, ... 만 추가
    }
    
    // ================================================================
    // 2단계부터: step = 3, 4, 5, ... 간격으로 제거
    // ================================================================
    int step = 3;
    
    // step이 현재 남은 원소 수보다 작거나 같을 때만 제거 가능
    // step > size면 어떤 원소도 제거되지 않음 (종료)
    while (step <= (int)q.size()) {
        int size = q.size();    // 현재 단계의 원소 수
        int pos = 1;            // 현재 위치 (1-indexed)
        
        // 현재 단계의 모든 원소 순회
        for (int i = 0; i < size; i++) {
            int val = q.front();
            q.pop();
            
            // pos가 step의 배수가 아니면 다시 큐에 넣음 (유지)
            // step의 배수면 넣지 않음 (제거)
            if (pos % step != 0) {
                q.push(val);
            }
            // else: step의 배수 위치 → 제거 (아무것도 안 함)
            
            pos++;
        }
        
        // 다음 단계로
        step++;
    }
    
    // ================================================================
    // 큐의 내용을 벡터로 변환
    // ================================================================
    vector<int> result;
    while (!q.empty()) {
        result.push_back(q.front());
        q.pop();
    }
    return result;
}

/*
 * ============================================================================
 * main() - 프로그램 진입점
 * ============================================================================
 * 
 * [입력]
 * - n: 럭키 넘버인지 확인할 숫자
 * 
 * [출력]
 * - "yes": n이 럭키 넘버
 * - "no": n이 럭키 넘버 아님
 * 
 * [실행 흐름]
 * 1. n 이하의 모든 럭키 넘버 생성
 * 2. 생성된 럭키 넘버들 중 n이 있는지 검색
 * 3. 결과 출력
 * 
 * [성능 고려]
 * - n이 클 경우 많은 메모리 사용
 * - 단일 숫자 판별만 필요하면 prob07.cpp 방식이 효율적
 * - 여러 숫자를 판별해야 하면 이 방식이 효율적 (한 번 생성 후 여러 번 검색)
 */
int main() {
    // 빠른 입출력
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    cin >> n;
    
    // n 이하의 모든 럭키 넘버 생성
    vector<int> lucky = generateLuckyNumbers(n);
    
    // 선형 검색으로 n이 럭키 넘버인지 확인
    // (이진 검색도 가능 - 결과가 정렬되어 있음)
    bool found = false;
    for (int x : lucky) {
        if (x == n) {
            found = true;
            break;
        }
    }
    
    // 결과 출력
    if (found) {
        cout << "yes" << endl;
    }
    else {
        cout << "no" << endl;
    }
    
    return 0;
}
