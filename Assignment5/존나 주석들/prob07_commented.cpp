/*
 * ============================================================================
 * prob07.cpp - 럭키 넘버(Lucky Number) 판별
 * ============================================================================
 * 
 * [럭키 넘버란?]
 * - 고대 폴란드의 수학 문제에서 유래한 수열
 * - 에라토스테네스의 체와 유사하지만, 위치 기반으로 제거
 * 
 * [럭키 넘버 생성 과정]
 * 1. 자연수 나열: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, ...
 * 2. 2의 배수 위치 제거: 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, ...
 * 3. 3의 배수 위치 제거: 1, 3, 7, 9, 13, 15, 19, 21, 25, ...
 *    (5, 11, 17, 23, ... 제거됨 - 3번째, 6번째, 9번째...)
 * 4. 4의 배수 위치 제거: 1, 3, 7, 13, 15, 19, 25, ...
 *    (9, 21, ... 제거됨 - 4번째, 8번째...)
 * 5. 계속 반복...
 * 
 * 결과: 1, 3, 7, 9, 13, 15, 21, 25, 31, 33, ...
 * 
 * [알고리즘]
 * - 재귀적으로 각 단계에서 n의 새로운 위치를 계산
 * - 제거되는 위치(step의 배수)에 있으면 럭키 넘버가 아님
 * - step이 현재 위치보다 크면 더 이상 제거되지 않음 → 럭키 넘버
 * 
 * [최적화]
 * - 짝수는 2단계에서 모두 제거됨 → 바로 false 반환
 * - 실제 수열을 생성하지 않고 위치만 추적
 * 
 * [시간 복잡도] O(√n) - step이 pos보다 커질 때까지 반복
 */

#include <iostream>
using namespace std;

/*
 * ============================================================================
 * is_luckyNum() - 특정 위치가 step 단계에서 살아남는지 확인
 * ============================================================================
 * 
 * [매개변수]
 * - pos: 현재 단계에서 n의 위치 (1-indexed)
 * - step: 현재 단계의 제거 간격
 * 
 * [반환값]
 * - true: 이 숫자가 럭키 넘버임
 * - false: 이 숫자가 제거됨
 * 
 * [동작 원리]
 * 
 * 1. 종료 조건: step > pos
 *    - 현재 위치보다 제거 간격이 크면
 *    - 더 이상 이 숫자가 제거될 일 없음
 *    - 럭키 넘버 확정!
 * 
 * 2. 제거 여부 확인: pos % step == 0
 *    - pos가 step의 배수면 이 단계에서 제거됨
 *    - 럭키 넘버 아님!
 * 
 * 3. 새 위치 계산: newPos = pos - (pos / step)
 *    - 현재 위치에서 "앞에서 제거된 원소 개수"를 뺌
 *    - pos / step = pos 앞에 있는 step의 배수 개수
 *    - 이것이 다음 단계에서의 새 위치
 * 
 * [예시] n = 7 검증
 * 
 * 초기: 홀수만 남은 수열에서 7의 위치 = (7+1)/2 = 4
 * 
 * 수열: [1, 3, 5, 7, 9, 11, 13, ...]
 *       위치: 1  2  3  4  5  6   7
 * 
 * is_luckyNum(4, 3):
 * - step(3) <= pos(4) → 진행
 * - pos % step = 4 % 3 = 1 ≠ 0 → 제거 안 됨
 * - newPos = 4 - (4/3) = 4 - 1 = 3
 * - 3의 배수 위치(3, 6, 9...)의 5, 11, 17... 제거
 * - 새 수열: [1, 3, 7, 9, 13, ...], 7은 3번째
 * 
 * is_luckyNum(3, 4):
 * - step(4) > pos(3) → true 반환!
 * - 7은 럭키 넘버!
 * 
 * [예시] n = 9 검증
 * 
 * 초기 위치 = (9+1)/2 = 5
 * 
 * is_luckyNum(5, 3):
 * - 5 % 3 = 2 ≠ 0 → 제거 안 됨
 * - newPos = 5 - 1 = 4
 * 
 * is_luckyNum(4, 4):
 * - 4 % 4 = 0 → 제거됨!
 * - 9는 럭키 넘버 아님!
 */
bool is_luckyNum(int pos, int step){
    // 종료 조건: 더 이상 제거될 위험 없음
    if (step > pos) {
        return true;
    }
    
    // 이 단계에서 제거되는지 확인
    if (pos % step == 0) {
        return false;
    }
    
    // 다음 단계의 새 인덱스 계산
    // 현재 인덱스 - 앞에서 제거된 원소 개수
    int newPos = pos - (pos / step);
    
    // 다음 단계로 재귀 호출
    return is_luckyNum(newPos, step + 1);
}

/*
 * ============================================================================
 * is_lucky() - 숫자 n이 럭키 넘버인지 판별
 * ============================================================================
 * 
 * [매개변수]
 * - n: 판별할 숫자
 * 
 * [반환값]
 * - true: n이 럭키 넘버
 * - false: n이 럭키 넘버 아님
 * 
 * [동작 원리]
 * 
 * 1. 짝수 사전 차단:
 *    - 2단계에서 모든 짝수 위치(2, 4, 6, ...)가 제거됨
 *    - 짝수는 절대 럭키 넘버가 될 수 없음
 * 
 * 2. 초기 위치 계산:
 *    - 2단계 후 홀수만 남은 수열: 1, 3, 5, 7, 9, ...
 *    - 숫자 n의 위치 = (n + 1) / 2
 *    - 예: 7 → (7+1)/2 = 4번째
 *    - 예: 13 → (13+1)/2 = 7번째
 * 
 * 3. 3의 배수 단계부터 시작:
 *    - 2단계(짝수 제거)는 이미 처리됨
 *    - 3단계(3의 배수 위치 제거)부터 검사
 */
bool is_lucky(int n){
    // 짝수는 럭키 넘버가 될 수 없음
    if (n % 2 == 0) {
        return false;
    }
    
    // 홀수만 남은 수열에서의 n의 위치 계산
    // 1→1, 3→2, 5→3, 7→4, 9→5, ...
    int pos = (n + 1) / 2;
    
    // 3의 배수 단계부터 시작하여 검사
    return is_luckyNum(pos, 3);
}

/*
 * ============================================================================
 * main() - 프로그램 진입점
 * ============================================================================
 * 
 * [입력]
 * - n: 판별할 양의 정수
 * 
 * [출력]
 * - "yes": n이 럭키 넘버
 * - "no": n이 럭키 넘버 아님
 * 
 * [참고]
 * - 출력문에 괄호 우선순위 문제가 있음
 * - cout << is_lucky(n) ? "yes" : "no"; 에서
 *   << 연산자가 ? 보다 우선순위가 높아서
 *   (cout << is_lucky(n)) ? "yes" : "no" 로 해석됨
 * - 올바른 코드: cout << (is_lucky(n) ? "yes" : "no");
 */
int main(){
    int n;
    cin >> n;
    
    // 주의: 연산자 우선순위 문제
    // 아래 코드는 (cout << is_lucky(n)) ? "yes" : "no" 로 해석됨
    // is_lucky(n)의 bool 값만 출력되고 "yes"/"no"는 무시됨
    cout << is_lucky(n) ? "yes" : "no";
    
    // 올바른 코드:
    // cout << (is_lucky(n) ? "yes" : "no");
    
    return 0;
}
