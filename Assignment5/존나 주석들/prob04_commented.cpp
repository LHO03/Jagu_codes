/*
 * ============================================================================
 * prob04.cpp - 정렬된 배열에서 Floor와 Ceiling 찾기
 * ============================================================================
 * 
 * [문제 개요]
 * - 정렬된 배열에서 주어진 값 K에 대해:
 *   - Floor: K보다 작거나 같은 가장 큰 값
 *   - Ceiling: K보다 크거나 같은 가장 작은 값
 * 
 * [알고리즘]
 * - 재귀적 선형 탐색으로 구현
 * - Floor: 뒤에서부터 탐색하여 K 이하인 첫 번째 값
 * - Ceiling: 앞에서부터 탐색하여 K 이상인 첫 번째 값
 * 
 * [시간 복잡도] O(N) - 선형 탐색
 * [공간 복잡도] O(N) - 재귀 호출 스택
 * 
 * [개선 가능성]
 * - 이진 탐색으로 O(log N)에 구현 가능
 * - 하지만 이 코드는 개념 이해를 위한 재귀적 구현
 * 
 * [주의]
 * - 입력 배열이 오름차순으로 정렬되어 있어야 함
 * - floor 함수에 모든 경로에서 반환값이 없는 경고가 있을 수 있음 (ignite[end] == K인 경우)
 */

#include <iostream>
using namespace std;

const int MAX = 1000;   // 배열 최대 크기
int ignite[MAX];        // 정렬된 입력 배열

/*
 * ============================================================================
 * floor() - K보다 작거나 같은 가장 큰 값 찾기
 * ============================================================================
 * 
 * [매개변수]
 * - end: 현재 검사할 인덱스 (뒤에서부터 탐색)
 * - K: 기준 값
 * 
 * [반환값]
 * - K 이하인 가장 큰 값
 * - 그런 값이 없으면 -1
 * 
 * [동작 원리]
 * - 배열의 뒤(큰 값)에서 앞(작은 값)으로 탐색
 * - K보다 큰 값이면 계속 앞으로 이동
 * - K보다 작거나 같은 값을 찾으면 반환
 * 
 * [예시] 배열 = [1, 3, 5, 7, 9], K = 6
 * 
 * - end=4: ignite[4]=9 > 6 → 계속 탐색
 * - end=3: ignite[3]=7 > 6 → 계속 탐색
 * - end=2: ignite[2]=5 < 6 → 반환 5
 * - Floor(6) = 5 (6보다 작거나 같은 가장 큰 값)
 * 
 * [참고]
 * - 정렬된 배열이므로 뒤에서부터 탐색하면
 *   첫 번째로 K 이하인 값이 곧 가장 큰 floor 값
 * 
 * [버그 주의]
 * - ignite[end] == K인 경우 반환문이 없음 (컴파일러 경고 발생 가능)
 * - 올바른 구현은 `if (ignite[end] <= K) return ignite[end];`
 */
int floor(int end, int K){
    // 기저 조건: 배열 범위를 벗어남
    // 모든 원소가 K보다 크면 floor 없음
    if (end < 0) { return -1; }

    // K보다 큰 값이면 계속 앞으로 이동
    if (ignite[end] > K) return floor(end - 1, K);
    
    // K보다 작거나 같은 값 발견 → 이것이 floor
    if (ignite[end] < K) return ignite[end];
    
    // 주의: ignite[end] == K인 경우 여기서 암묵적으로 처리되지 않음
    // 실제로는 ignite[end] <= K로 합쳐야 안전
    // (이 경우 함수가 값을 반환하지 않아 undefined behavior)
}

/*
 * ============================================================================
 * ceiling() - K보다 크거나 같은 가장 작은 값 찾기
 * ============================================================================
 * 
 * [매개변수]
 * - start: 현재 검사할 인덱스 (앞에서부터 탐색)
 * - end: 배열의 마지막 인덱스 (경계 체크용)
 * - K: 기준 값
 * 
 * [반환값]
 * - K 이상인 가장 작은 값
 * - 그런 값이 없으면 -1
 * 
 * [동작 원리]
 * - 배열의 앞(작은 값)에서 뒤(큰 값)로 탐색
 * - K보다 작은 값이면 계속 뒤로 이동
 * - K보다 크거나 같은 값을 찾으면 반환
 * 
 * [예시] 배열 = [1, 3, 5, 7, 9], K = 6
 * 
 * - start=0: ignite[0]=1 < 6 → 계속 탐색
 * - start=1: ignite[1]=3 < 6 → 계속 탐색
 * - start=2: ignite[2]=5 < 6 → 계속 탐색
 * - start=3: ignite[3]=7 >= 6 → 반환 7
 * - Ceiling(6) = 7 (6보다 크거나 같은 가장 작은 값)
 * 
 * [참고]
 * - 정렬된 배열이므로 앞에서부터 탐색하면
 *   첫 번째로 K 이상인 값이 곧 가장 작은 ceiling 값
 */
int ceiling(int start, int end, int K) {
    // 기저 조건: 배열 범위를 벗어남
    // 모든 원소가 K보다 작으면 ceiling 없음
    if (start > end) { return -1; }

    // K보다 작은 값이면 계속 뒤로 이동
    if (ignite[start] < K) return ceiling(start + 1, end, K);
    
    // K보다 크거나 같은 값 발견 → 이것이 ceiling
    if (ignite[start] >= K) return ignite[start];
}

/*
 * ============================================================================
 * main() - 프로그램 진입점
 * ============================================================================
 * 
 * [입력 형식]
 * - 첫 줄: N (배열 크기)
 * - 둘째 줄: N개의 정수 (오름차순 정렬되어 있어야 함)
 * - 셋째 줄: K (기준 값)
 * 
 * [출력]
 * - Floor 값 (K 이하인 가장 큰 값)
 * - Ceiling 값 (K 이상인 가장 작은 값)
 * 
 * [예시]
 * 입력: [1, 3, 5, 7, 9], K = 6
 * 출력: 5 (floor), 7 (ceiling)
 */
int main(void){
    int N, K;
    
    cin >> N;
    for (int i = 0; i < N; i++) {
        cin >> ignite[i];
    }
    cin >> K;

    // Floor: 뒤(N-1)에서부터 탐색
    // Ceiling: 앞(0)에서부터 탐색
    cout << endl << floor(N - 1, K) << endl << ceiling(0, N - 1, K);
    
    return 0;
}
