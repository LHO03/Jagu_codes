/*
 * ============================================================================
 * prob08.cpp - BFS를 이용한 장기 '포' 이동 가능 여부 판별
 * ============================================================================
 * 
 * [문제 개요]
 * - N×N 장기판에서 '포'가 시작 위치에서 목표 위치까지 이동 가능한지 판별
 * - 포의 이동 규칙: 반드시 다른 말 하나를 뛰어넘어야 이동 가능
 * 
 * [포의 이동 규칙 상세]
 * 1. 포는 가로/세로 방향으로만 이동 가능
 * 2. 반드시 정확히 하나의 말(장애물)을 뛰어넘어야 함
 * 3. 뛰어넘은 후 두 번째 장애물을 만나기 전까지의 빈 칸에 착지 가능
 * 4. 장애물이 없거나, 뛰어넘을 말 바로 뒤에 또 다른 말이 있으면 이동 불가
 * 
 * [시각화 예시] (P: 포, X: 다른 말, O: 착지 가능, .: 빈 칸)
 * 
 *   P . . X O O O X . .
 *   ↑     ↑       ↑
 *   포   장애물  두번째 장애물
 *        뛰어넘음  여기까지 착지 가능
 * 
 * [알고리즘]
 * - BFS로 모든 도달 가능한 위치를 탐색
 * - 각 위치에서 4방향으로 포 규칙에 따른 이동 시도
 * - 목표 위치에 도달하면 즉시 true 반환
 * 
 * [시간 복잡도] O(N² × N) = O(N³) - 각 칸에서 최대 N칸까지 탐색
 * [공간 복잡도] O(N²) - 방문 배열 및 BFS 큐
 */

#include <iostream>
#include <fstream>
#include <queue>
#include <vector>
using namespace std;

// ============================================================================
// 상수 정의
// ============================================================================
const int MAX = 16;     // 장기판 최대 크기
const int SQUARE = 0;   // 빈 칸 (이동 가능한 공간)
const int UNIT = 1;     // 다른 말이 있는 칸 (장애물)

/*
 * ============================================================================
 * Position 구조체 - 장기판 위의 위치
 * ============================================================================
 */
struct Position {
    int x, y;
    Position() = default;
    Position(int x, int y) : x(x), y(y) {}
};

// ============================================================================
// 전역 변수
// ============================================================================
int N;                      // 장기판 크기
int pan[MAX][MAX];          // 장기판 상태 (0: 빈 칸, 1: 말 있음)
bool visited[MAX][MAX];     // BFS 방문 여부
Position src, des;          // 시작 위치(src), 목표 위치(des)

// ============================================================================
// 방향 오프셋 배열
// ============================================================================
// 상(북), 우(동), 하(남), 좌(서) - 포는 4방향 직선 이동만 가능
int offset[4][2] = {
    {-1, 0},    // 상 (위)
    {0, 1},     // 우 (오른쪽)
    {1, 0},     // 하 (아래)
    {0, -1}     // 좌 (왼쪽)
};

/*
 * ============================================================================
 * read_pan() - 파일에서 장기판 데이터 읽기
 * ============================================================================
 * 
 * [파일 형식] input8.txt
 * - 첫 줄: N (장기판 크기)
 * - 다음 N줄: N×N 장기판 (0: 빈 칸, 1: 말 있음)
 * - 다음 줄: src.x src.y (시작 위치)
 * - 마지막 줄: des.x des.y (목표 위치)
 */
void read_pan() {
    ifstream chess_pan("input8.txt");
    chess_pan >> N;
    
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            chess_pan >> pan[i][j];
        }
    }
    
    chess_pan >> src.x >> src.y;
    chess_pan >> des.x >> des.y;
    chess_pan.close();
}

/*
 * ============================================================================
 * in_range() - 좌표가 장기판 범위 내인지 확인
 * ============================================================================
 */
bool in_range(int x, int y) {
    return x >= 0 && x < N && y >= 0 && y < N;
}

/*
 * ============================================================================
 * can_moves() - 특정 위치에서 특정 방향으로 포가 이동 가능한 모든 위치 계산
 * ============================================================================
 * 
 * [매개변수]
 * - cur: 현재 포의 위치
 * - dir: 이동 방향 (0: 상, 1: 우, 2: 하, 3: 좌)
 * - destinations: 착지 가능한 위치들을 저장할 벡터 (출력 파라미터)
 * 
 * [알고리즘 상세]
 * 
 * [1단계] 첫 번째 장애물(UNIT) 찾기
 * - 현재 위치에서 dir 방향으로 진행
 * - 빈 칸(SQUARE)을 지나면서 첫 번째 말(UNIT)을 찾음
 * - 범위를 벗어나거나 장애물을 못 찾으면 이동 불가 (return)
 * 
 *   P . . . X ...
 *   ↑       ↑
 *   현재위치  첫 번째 장애물 발견!
 * 
 * [2단계] 착지 가능 위치 수집
 * - 첫 번째 장애물을 건너뛴 후 계속 진행
 * - 두 번째 장애물(UNIT)을 만나기 전까지의 모든 빈 칸이 착지 가능
 * - 각 빈 칸을 destinations 벡터에 추가
 * 
 *   P . . . X O O O X . .
 *           ↑ ↑ ↑ ↑ ↑
 *         뛰어넘음 |___|  두 번째 장애물
 *                  착지 가능한 위치들
 * 
 * [포 규칙 정리]
 * - 반드시 하나의 말을 뛰어넘어야 함 (뛰어넘을 말 없으면 이동 불가)
 * - 뛰어넘은 직후 연속으로 말이 있으면 그 방향 착지 불가
 * - 두 번째 말을 만나면 그 이후로는 착지 불가
 */
void can_moves(Position cur, int dir, vector<Position>& destinations) {
    int dx = offset[dir][0];
    int dy = offset[dir][1];
    
    // 다음 위치 초기화
    int nx = cur.x + dx;
    int ny = cur.y + dy;
    
    // ================================================================
    // [1단계] 첫 번째 장애물(UNIT) 찾기
    // ================================================================
    // 포는 반드시 하나의 말을 건너뛰어야 이동 가능
    // 빈 칸(SQUARE)을 지나면서 첫 번째 말(UNIT)을 찾음
    while (in_range(nx, ny) && pan[nx][ny] == SQUARE) {
        nx += dx;
        ny += dy;
    }
    
    // 범위를 벗어났거나 장애물을 찾지 못한 경우
    // → 뛰어넘을 말이 없으므로 이동 불가
    if (!in_range(nx, ny) || pan[nx][ny] != UNIT) {
        return;
    }
    
    // ================================================================
    // [2단계] 장애물을 건너뛴 후 착지 가능한 위치 수집
    // ================================================================
    // 첫 번째 장애물 바로 다음 위치부터 탐색
    nx += dx;
    ny += dy;
    
    // 두 번째 장애물을 만나기 전까지 모든 빈 칸이 착지 가능
    while (in_range(nx, ny) && pan[nx][ny] == SQUARE) {
        // 이 위치에 착지 가능 → destinations에 추가
        destinations.push_back(Position(nx, ny));
        nx += dx;
        ny += dy;
    }
    
    // 두 번째 장애물(UNIT)을 만나거나 범위를 벗어나면 종료
}

/*
 * ============================================================================
 * Po() - BFS로 포가 시작 위치에서 목표 위치까지 도달 가능한지 판별
 * ============================================================================
 * 
 * [반환값]
 * - true: 도달 가능
 * - false: 도달 불가능
 * 
 * [알고리즘]
 * 1. 방문 배열 초기화
 * 2. 시작 위치를 큐에 넣고 방문 처리
 * 3. BFS 반복:
 *    a. 큐에서 위치 하나를 꺼냄
 *    b. 4방향으로 can_moves() 호출하여 착지 가능한 위치들 계산
 *    c. 각 착지 가능 위치에 대해:
 *       - 목표 위치면 true 반환
 *       - 미방문이면 방문 처리 후 큐에 추가
 * 4. 큐가 비면 false 반환 (도달 불가)
 * 
 * [BFS 선택 이유]
 * - 도달 가능 여부만 판별 (최단 거리 불필요)
 * - 모든 도달 가능한 위치를 체계적으로 탐색
 * - 한 번 방문한 위치는 다시 방문하지 않아 효율적
 */
bool Po() {
    // 방문 배열 초기화
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            visited[i][j] = false;
        }
    }
    
    // BFS 초기화
    queue<Position> q;
    q.push(src);
    visited[src.x][src.y] = true;
    
    while (!q.empty()) {
        Position cur = q.front();
        q.pop();
        
        // 네 방향으로 포 이동 시도
        for (int dir = 0; dir < 4; dir++) {
            vector<Position> destinations;
            can_moves(cur, dir, destinations);
            
            // 해당 방향으로 착지 가능한 모든 위치 처리
            for (int i = 0; i < destinations.size(); i++) {
                Position next = destinations[i];
                
                // 목표 위치 도달 시 즉시 종료
                if (next.x == des.x && next.y == des.y) {
                    return true;
                }
                
                // 미방문 위치면 큐에 추가
                if (!visited[next.x][next.y]) {
                    visited[next.x][next.y] = true;
                    q.push(next);
                }
            }
        }
    }
    
    // 큐가 비었는데도 목표에 도달하지 못함
    return false;
}

/*
 * ============================================================================
 * main() - 프로그램 진입점
 * ============================================================================
 * 
 * [출력]
 * - "Yes": 포가 목표 위치까지 이동 가능
 * - "No": 이동 불가능
 */
int main() {
    read_pan();
    
    cout << (Po() ? "Yes" : "No");
    
    return 0;
}
