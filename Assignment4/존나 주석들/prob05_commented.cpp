/*
 * ============================================================================
 * prob05.cpp - 중위 표기식(Infix Expression) 계산기
 * ============================================================================
 * 
 * [문제 개요]
 * - 중위 표기식(예: "3 + 4 * 2")을 입력받아 계산 결과를 출력
 * - 사칙연산(+, -, *, /)과 괄호를 지원
 * - 연산자 우선순위와 결합법칙 처리
 * 
 * [지원 기능]
 * - 사칙연산: +, -, *, /
 * - 괄호: ( )
 * - 소수점이 있는 숫자
 * - 단항 음수: -3, -(2+3), 5 * -3
 * 
 * [알고리즘]
 * - Shunting Yard 알고리즘의 변형
 * - 두 개의 스택 사용: 피연산자 스택(vals), 연산자 스택(ops)
 * - 연산자 우선순위에 따라 계산 시점 결정
 * 
 * [연산자 우선순위]
 * - 높음: *, / (우선순위 2)
 * - 낮음: +, - (우선순위 1)
 * - 괄호는 별도 처리 (우선순위 0)
 * 
 * [시간 복잡도] O(N) - 수식 길이에 비례
 * [공간 복잡도] O(N) - 스택 크기
 */

#include <iostream>
#include <string>
#include <stack>
#include <cctype>
#include <stdexcept>
using namespace std;

/*
 * ============================================================================
 * is_operator() - 문자가 연산자인지 확인
 * ============================================================================
 * 
 * [매개변수]
 * - ch: 확인할 문자
 * 
 * [반환값]
 * - true: +, -, *, / 중 하나
 * - false: 연산자가 아님
 */
bool is_operator(char ch) {
    return ch == '+' || ch == '-' || ch == '*' || ch == '/';
}

/*
 * ============================================================================
 * precedence() - 연산자의 우선순위 반환
 * ============================================================================
 * 
 * [매개변수]
 * - op: 연산자 문자
 * 
 * [반환값]
 * - 2: *, / (곱셈, 나눗셈)
 * - 1: +, - (덧셈, 뺄셈)
 * - 0: 그 외 (괄호 등)
 * 
 * [용도]
 * - 연산자 스택에서 pop 여부 결정
 * - 높은 우선순위 연산자가 먼저 계산됨
 */
int precedence(char op) {
    if (op == '+' || op == '-') return 1;
    if (op == '*' || op == '/') return 2;
    return 0;
}

/*
 * ============================================================================
 * apply_op() - 연산자를 두 피연산자에 적용
 * ============================================================================
 * 
 * [매개변수]
 * - vals: 피연산자 스택 (참조)
 * - op: 적용할 연산자
 * 
 * [동작]
 * 1. 스택에서 피연산자 2개 pop (rhs, lhs 순서)
 * 2. lhs op rhs 계산
 * 3. 결과를 스택에 push
 * 
 * [주의]
 * - pop 순서: 먼저 pop한 것이 rhs (오른쪽 피연산자)
 * - 나눗셈에서 0으로 나누기 체크
 * - 피연산자가 2개 미만이면 문법 오류
 * 
 * [예시]
 * 스택: [3, 5] (bottom→top), op='+'
 * rhs=5, lhs=3, result=3+5=8
 * 스택: [8]
 */
void apply_op(stack<double>& vals, char op) {
    // 피연산자가 2개 미만이면 오류
    if (vals.size() < 2) {
        throw runtime_error("Syntax Error: malformed expression.");
    }
    
    // 스택에서 피연산자 2개 pop
    // 먼저 pop한 것이 오른쪽 피연산자 (rhs)
    double rhs = vals.top();
    vals.pop();
    double lhs = vals.top();
    vals.pop();
    
    double result = 0;
    switch(op) {
        case '+': result = lhs + rhs; break;
        case '-': result = lhs - rhs; break;
        case '*': result = lhs * rhs; break;
        case '/':
            // 0으로 나누기 체크
            if (rhs == 0) {
                throw runtime_error("Math Error: division by zero.");
            }
            result = lhs / rhs;
            break;
    }
    
    // 결과를 스택에 push
    vals.push(result);
}

/*
 * ============================================================================
 * evaluate_infix() - 중위 표기식 계산
 * ============================================================================
 * 
 * [매개변수]
 * - expr: 중위 표기식 문자열
 * 
 * [반환값]
 * - 계산 결과 (double)
 * 
 * [알고리즘 - Shunting Yard 변형]
 * 
 * 두 개의 스택:
 * - vals: 피연산자(숫자) 스택
 * - ops: 연산자 스택
 * 
 * 수식을 왼쪽에서 오른쪽으로 스캔하며:
 * 
 * 1. 숫자: vals에 push
 * 
 * 2. 연산자 (+, -, *, /):
 *    - ops의 top 연산자와 우선순위 비교
 *    - top의 우선순위가 >= 현재 연산자 → apply_op 후 pop
 *    - 이를 반복 후 현재 연산자 push
 * 
 * 3. 여는 괄호 '(':
 *    - ops에 무조건 push
 *    - 괄호 안은 별도의 계산 영역
 * 
 * 4. 닫는 괄호 ')':
 *    - '('를 만날 때까지 apply_op 후 pop
 *    - '(' pop (제거)
 * 
 * 5. 수식 끝:
 *    - ops가 빌 때까지 apply_op 후 pop
 *    - vals에 남은 하나의 값이 결과
 * 
 * [단항 음수 처리]
 * - 수식 시작, '(' 뒤, 연산자 뒤의 '-'는 단항 음수
 * - 경우에 따라 처리:
 *   a. -3, -2.5: 음수를 직접 파싱
 *   b. -(expr): 0을 push 후 '-'를 이항 연산자로 처리 (0 - expr)
 * 
 * [예시] "3 + 4 * 2"
 * 
 * '3': vals=[3], ops=[]
 * '+': vals=[3], ops=['+']
 * '4': vals=[3,4], ops=['+']
 * '*': '*'(2) > '+'(1), push, vals=[3,4], ops=['+','*']
 * '2': vals=[3,4,2], ops=['+','*']
 * 끝: apply '*' → vals=[3,8], ops=['+']
 *     apply '+' → vals=[11], ops=[]
 * 결과: 11
 */
double evaluate_infix(const string& expr) {
    stack<double> vals;      // 피연산자 스택
    stack<char> ops;         // 연산자 스택
    
    int i = 0;
    int len = expr.length();
    
    while (i < len) {
        // ================================================================
        // 공백 무시
        // ================================================================
        if (isspace(expr[i])) {
            i++;
            continue;
        }
        
        // ================================================================
        // 숫자 토큰 파싱 (양수)
        // ================================================================
        if (isdigit(expr[i]) || expr[i] == '.') {
            string num_str;
            // 숫자와 소수점을 모두 파싱
            while (i < len && (isdigit(expr[i]) || expr[i] == '.')) {
                num_str += expr[i];
                i++;
            }
            vals.push(stod(num_str));   // 문자열 → double 변환 후 push
        }
        // ================================================================
        // 단항 음수 또는 이항 '-' 처리
        // ================================================================
        else if (expr[i] == '-') {
            bool is_unary = false;
            
            // 이전 의미있는 문자 찾기 (공백 건너뛰기)
            int j = i - 1;
            while (j >= 0 && isspace(expr[j])) j--;
            
            // 단항 음수 조건:
            // - 수식의 시작 (j < 0)
            // - 여는 괄호 뒤 (expr[j] == '(')
            // - 연산자 뒤 (is_operator(expr[j]))
            if (j < 0 || expr[j] == '(' || is_operator(expr[j])) {
                is_unary = true;
            }
            
            if (is_unary) {
                // ========================================================
                // 단항 음수: 숫자의 일부로 파싱
                // ========================================================
                i++;    // '-' 건너뛰기
                
                // 공백 건너뛰기
                while (i < len && isspace(expr[i])) i++;
                
                if (i >= len) {
                    throw runtime_error("Syntax Error: invalid character.");
                }
                
                // 괄호 뒤의 단항 음수인 경우: -(expr)
                // 0 - expr로 처리
                if (expr[i] == '(') {
                    vals.push(0);       // 0을 피연산자로 push
                    ops.push('-');      // '-'를 이항 연산자로 처리
                    continue;
                }
                
                // 숫자 앞의 단항 음수: -3, -2.5
                string num_str = "-";
                if (isdigit(expr[i]) || expr[i] == '.') {
                    while (i < len && (isdigit(expr[i]) || expr[i] == '.')) {
                        num_str += expr[i];
                        i++;
                    }
                    vals.push(stod(num_str));   // 음수로 파싱
                } else {
                    throw runtime_error("Syntax Error: invalid character.");
                }
            } else {
                // ========================================================
                // 이항 연산자로 처리
                // ========================================================
                // 스택 top의 연산자보다 우선순위가 낮거나 같으면 pop하여 계산
                while (!ops.empty() && ops.top() != '(' && 
                       precedence(ops.top()) >= precedence('-')) {
                    apply_op(vals, ops.top());
                    ops.pop();
                }
                ops.push('-');
                i++;
            }
        }
        // ================================================================
        // 여는 괄호: 무조건 스택에 push
        // ================================================================
        // 괄호는 계산 영역의 경계 역할
        // 스택 내 어떤 연산자도 pop하지 않음
        else if (expr[i] == '(') {
            ops.push('(');
            i++;
        }
        // ================================================================
        // 닫는 괄호: 여는 괄호를 만날 때까지 계산
        // ================================================================
        else if (expr[i] == ')') {
            // '('를 만날 때까지 연산자를 pop하여 계산
            while (!ops.empty() && ops.top() != '(') {
                apply_op(vals, ops.top());
                ops.pop();
            }
            
            // '('가 없으면 괄호 불일치
            if (ops.empty()) {
                throw runtime_error("Syntax Error: unmatched parenthesis.");
            }
            
            ops.pop();  // '(' 제거
            i++;
        }
        // ================================================================
        // 일반 연산자 (+, *, /)
        // ================================================================
        else if (is_operator(expr[i])) {
            char op = expr[i];
            
            // 스택 top의 연산자와 우선순위 비교
            // - 여는 괄호가 있으면 비교하지 않고 push
            // - 우선순위가 높으면 push
            // - 낮거나 같으면 pop하여 계산 후 push
            while (!ops.empty() && ops.top() != '(' && 
                   precedence(ops.top()) >= precedence(op)) {
                apply_op(vals, ops.top());
                ops.pop();
            }
            ops.push(op);
            i++;
        }
        // ================================================================
        // 알 수 없는 문자
        // ================================================================
        else {
            throw runtime_error("Syntax Error: invalid character.");
        }
    }
    
    // ================================================================
    // 남은 연산자를 모두 처리
    // ================================================================
    while (!ops.empty()) {
        // 남은 '('가 있으면 괄호 불일치
        if (ops.top() == '(') {
            throw runtime_error("Syntax Error: unmatched parenthesis.");
        }
        apply_op(vals, ops.top());
        ops.pop();
    }
    
    // ================================================================
    // 최종 결과 반환
    // ================================================================
    // vals에는 정확히 하나의 값만 남아야 함
    if (vals.size() != 1) {
        throw runtime_error("Syntax Error: malformed expression.");
    }
    
    return vals.top();
}

/*
 * ============================================================================
 * main() - 프로그램 진입점
 * ============================================================================
 * 
 * [입력]
 * - 한 줄의 중위 표기식
 * 
 * [출력]
 * - 계산 결과 (최대 15자리 정밀도)
 * - 오류 발생 시 오류 메시지
 */
int main() {
    string expr;
    getline(cin, expr);     // 공백 포함 전체 줄 입력
    
    try {
        double result = evaluate_infix(expr);
        cout.precision(15);     // 출력 정밀도 설정
        cout << result << '\n';
    } catch (exception& e) {
        cout << e.what() << '\n';
    }
    
    return 0;
}
