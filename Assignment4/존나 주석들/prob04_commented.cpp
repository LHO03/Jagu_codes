/*
 * ============================================================================
 * prob04.cpp - 8방향 연결 컴포넌트(Connected Component) 크기 계산
 * ============================================================================
 * 
 * [문제 개요]
 * - N×N 이진 격자에서 1로 이루어진 연결 컴포넌트들을 찾음
 * - 8방향(상하좌우 + 대각선 4방향)으로 연결된 1들을 하나의 컴포넌트로 간주
 * - 각 컴포넌트의 크기(셀 개수)를 오름차순으로 출력
 * 
 * [8방향 연결 vs 4방향 연결]
 * - 4방향: 상하좌우만 연결로 인정
 * - 8방향: 대각선도 연결로 인정 (더 많은 셀이 하나의 컴포넌트로 묶임)
 * 
 * [예시] 8방향 연결
 *     1 0 0
 *     0 1 0    → 이 세 개의 1은 대각선으로 연결되어 하나의 컴포넌트
 *     0 0 1
 * 
 * [알고리즘]
 * - 스택 기반 DFS (반복적 구현)
 * - 격자를 스캔하며 미방문 1을 발견하면 새 컴포넌트 시작
 * - DFS로 연결된 모든 1을 방문하며 크기 계산
 * 
 * [시간 복잡도] O(T × N²) - T개의 테스트 케이스, 각 N×N 격자
 * [공간 복잡도] O(N²) - 방문 배열 및 DFS 스택
 */

#include <iostream>
#include <fstream>
#include <vector>
#include <stack>
#include <algorithm>
#include <string>
#include <sstream>

using namespace std;

/*
 * ============================================================================
 * 8방향 델타 (Direction Offset)
 * ============================================================================
 * 
 * [배열 구조]
 * - dy[i]: y(행) 방향 이동량
 * - dx[i]: x(열) 방향 이동량
 * 
 * [8방향 매핑]
 * dir=0: 상좌 (↖)  dy=-1, dx=-1
 * dir=1: 상   (↑)  dy=-1, dx=0
 * dir=2: 상우 (↗)  dy=-1, dx=+1
 * dir=3: 좌   (←)  dy=0,  dx=-1
 * dir=4: 우   (→)  dy=0,  dx=+1
 * dir=5: 하좌 (↙)  dy=+1, dx=-1
 * dir=6: 하   (↓)  dy=+1, dx=0
 * dir=7: 하우 (↘)  dy=+1, dx=+1
 * 
 * [참고]
 * - (y, x) 좌표 시스템 사용 (행, 열)
 * - y가 행(세로), x가 열(가로)
 */
const int dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};
const int dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};

/*
 * ============================================================================
 * component_sizes() - 모든 연결 컴포넌트의 크기를 계산
 * ============================================================================
 * 
 * [매개변수]
 * - grid: N×N 이진 격자 (0 또는 1)
 * 
 * [반환값]
 * - 각 컴포넌트의 크기를 담은 벡터 (정렬되지 않은 상태)
 * 
 * [알고리즘 상세]
 * 
 * 1. 방문 배열 초기화:
 *    - visited[i][j] = false로 초기화
 * 
 * 2. 격자 전체 스캔:
 *    - grid[i][j] == 1 && !visited[i][j] → 새 컴포넌트 발견
 * 
 * 3. 스택 기반 DFS:
 *    a. 시작점 (i, j)를 스택에 push, 방문 처리
 *    b. 스택이 빌 때까지:
 *       - pop하여 현재 위치 (y, x) 획득
 *       - comp_size++ (컴포넌트 크기 증가)
 *       - 8방향 이웃 검사:
 *         - 범위 내 && 값이 1 && 미방문 → push, 방문 처리
 *    c. DFS 종료 시 comp_size를 결과에 추가
 * 
 * [스택 기반 DFS vs 재귀 DFS]
 * - 스택 기반: 깊은 재귀로 인한 스택 오버플로우 방지
 * - 재귀 기반: 코드가 더 간결하지만 깊이 제한 있음
 * - N이 클 때(예: 1000×1000) 스택 기반이 안전
 * 
 * [방문 처리 시점]
 * - push할 때 방문 처리 (스택에 넣을 때)
 * - pop할 때 처리하면 같은 셀이 여러 번 스택에 들어갈 수 있음
 * - 이 방식이 메모리와 시간 효율적
 */
vector<int> component_sizes(const vector<vector<int>>& grid) {
    int N = grid.size();
    
    // 방문 배열 초기화
    vector<vector<bool>> visited(N, vector<bool>(N, false));
    vector<int> comps;      // 컴포넌트 크기들을 저장
    
    // 전체 격자 스캔
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            // ============================================================
            // 새 컴포넌트 발견
            // ============================================================
            // 아직 방문하지 않은 1을 발견 → 새 컴포넌트 시작
            if (grid[i][j] == 1 && !visited[i][j]) {
                int comp_size = 0;
                stack<pair<int, int>> st;
                
                // 시작점을 스택에 push
                st.push({i, j});
                visited[i][j] = true;   // push할 때 방문 처리!
                
                // ========================================================
                // 반복적 DFS
                // ========================================================
                while (!st.empty()) {
                    pair<int, int> cur = st.top();
                    st.pop();
                    
                    int y = cur.first;      // 현재 행
                    int x = cur.second;     // 현재 열
                    comp_size++;            // 컴포넌트 크기 증가
                    
                    // 8방향 이웃 검사
                    for (int dir = 0; dir < 8; dir++) {
                        int ny = y + dy[dir];   // 이웃 행
                        int nx = x + dx[dir];   // 이웃 열
                        
                        // 범위 체크 && 값이 1 && 미방문
                        if (ny >= 0 && ny < N && nx >= 0 && nx < N &&
                            grid[ny][nx] == 1 && !visited[ny][nx]) {
                            st.push({ny, nx});
                            visited[ny][nx] = true;     // push할 때 방문 처리!
                        }
                    }
                }
                
                // 컴포넌트 탐색 완료, 크기 저장
                comps.push_back(comp_size);
            }
        }
    }
    
    return comps;
}

/*
 * ============================================================================
 * main() - 프로그램 진입점
 * ============================================================================
 * 
 * [입력 형식]
 * - 파일 "input.txt" 또는 표준 입력
 * - 첫 줄: T (테스트 케이스 수)
 * - 각 테스트 케이스:
 *   - 첫 줄: N (격자 크기)
 *   - 다음 N줄: N개의 0 또는 1
 * 
 * [출력 형식]
 * - 각 테스트 케이스마다 한 줄
 * - 컴포넌트 크기들을 오름차순으로 공백 구분 출력
 * - 컴포넌트가 없으면 빈 줄
 * 
 * [파일 입력 폴백]
 * - input.txt 파일이 있으면 파일에서 읽음
 * - 없으면 표준 입력(cin)에서 읽음
 */
int main() {
    // 파일 입력 시도, 실패하면 표준 입력 사용
    ifstream fin("input.txt");
    istream& input = fin.is_open() ? fin : cin;
    
    int T;
    input >> T;     // 테스트 케이스 수
    
    while (T--) {
        int N;
        input >> N;
        
        // 격자 입력
        vector<vector<int>> grid(N, vector<int>(N));
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                input >> grid[i][j];
            }
        }
        
        // 컴포넌트 크기 계산
        vector<int> comps = component_sizes(grid);
        
        // 오름차순 정렬
        sort(comps.begin(), comps.end());
        
        // 출력: 컴포넌트가 없으면 빈 줄, 있으면 크기들을 공백으로 구분
        for (int i = 0; i < comps.size(); i++) {
            if (i > 0) cout << ' ';
            cout << comps[i];
        }
        cout << '\n';
    }
    
    // 파일 닫기
    if (fin.is_open()) {
        fin.close();
    }
    
    return 0;
}
